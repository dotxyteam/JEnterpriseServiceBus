<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>InMemoryCompiler.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</a> &gt; <a href="../../index.html" class="el_group">j-enterprise-service-bus</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">com.otk.jesb.compiler</a> &gt; <span class="el_source">InMemoryCompiler.java</span></div><h1>InMemoryCompiler.java</h1><pre class="source lang-java linenums">package com.otk.jesb.compiler;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.Charset;
import java.rmi.server.UID;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.tools.Diagnostic;
import javax.tools.DiagnosticCollector;
import javax.tools.FileObject;
import javax.tools.ForwardingJavaFileManager;
import javax.tools.JavaCompiler;
import javax.tools.JavaCompiler.CompilationTask;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.JavaFileObject.Kind;
import javax.tools.SimpleJavaFileObject;
import javax.tools.ToolProvider;

import org.apache.commons.io.input.ReaderInputStream;

import com.otk.jesb.Log;
import com.otk.jesb.UnexpectedError;
import com.otk.jesb.meta.CompositeClassLoader;
import com.otk.jesb.meta.DelegatingClassLoader;
import com.otk.jesb.util.MiscUtils;

<span class="fc" id="L46">public class InMemoryCompiler {</span>

<span class="fc" id="L48">	private static final Class&lt;?&gt; CACHED_CLASS_NOT_FOUND = (new Object() {</span>
		@Override
		public String toString() {
<span class="nc" id="L51">			return &quot;CACHED_CLASS_NOT_FOUND&quot;;</span>
		}
<span class="fc" id="L53">	}).getClass();</span>

<span class="fc" id="L55">	private final Map&lt;ClassIdentifier, byte[]&gt; classBinaries = new HashMap&lt;&gt;();</span>
<span class="fc" id="L56">	private final Map&lt;String, List&lt;JavaFileObject&gt;&gt; packagingMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L57">	private final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span>
	private UID currentCompilationIdentifier;
<span class="fc" id="L59">	private Iterable&lt;String&gt; options = Arrays.asList(&quot;-parameters&quot;);</span>
<span class="fc" id="L60">	private final DelegatingClassLoader firstClassLoaderDelegator = new DelegatingClassLoader(</span>
<span class="fc" id="L61">			new URLClassLoader(new URL[0]));</span>
<span class="fc" id="L62">	private final CompiledClassesLoader compiledClassesLoader = new CompiledClassesLoader();</span>
<span class="fc" id="L63">	private final Map&lt;String, Class&lt;?&gt;&gt; classCache = new HashMap&lt;String, Class&lt;?&gt;&gt;();</span>
<span class="fc" id="L64">	private final Object compilationMutex = new Object();</span>
<span class="fc" id="L65">	private final Object classDataMutex = new Object();</span>
<span class="fc" id="L66">	private final Object classCacheMutex = new Object();</span>

	public byte[] getClassBinary(Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">		if (!(clazz.getClassLoader() instanceof MemoryClassLoader)) {</span>
<span class="nc" id="L70">			throw new IllegalArgumentException();</span>
		}
<span class="fc" id="L72">		ClassIdentifier classIdentifier = new ClassIdentifier(</span>
<span class="fc" id="L73">				((MemoryClassLoader) clazz.getClassLoader()).getMainClassIdentifier().getCompilationIdentifier(),</span>
<span class="fc" id="L74">				clazz.getName());</span>
<span class="fc" id="L75">		synchronized (classDataMutex) {</span>
<span class="fc" id="L76">			return classBinaries.get(classIdentifier);</span>
		}
	}

	public ClassLoader getCompiledClassesLoader() {
<span class="fc" id="L81">		return compiledClassesLoader;</span>
	}

	public URLClassLoader getFirstClassLoader() {
<span class="fc" id="L85">		return (URLClassLoader) firstClassLoaderDelegator.getDelegate();</span>
	}

	public void setFirstClassLoader(URLClassLoader classLoader) {
<span class="fc" id="L89">		firstClassLoaderDelegator.setDelegate(classLoader);</span>
<span class="fc" id="L90">		synchronized (classCacheMutex) {</span>
<span class="fc" id="L91">			classCache.clear();</span>
		}
<span class="fc" id="L93">	}</span>

	public Iterable&lt;String&gt; getOptions() {
<span class="nc" id="L96">		return options;</span>
	}

	public void setOptions(Iterable&lt;String&gt; options) {
<span class="nc" id="L100">		this.options = options;</span>
<span class="nc" id="L101">	}</span>

	public Class&lt;?&gt; loadClassThroughCache(String className) throws ClassNotFoundException {
<span class="fc" id="L104">		synchronized (classCacheMutex) {</span>
<span class="fc" id="L105">			Class&lt;?&gt; c = classCache.get(className);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">			if (c == null) {</span>
				try {
<span class="fc" id="L108">					c = compiledClassesLoader.loadClass(className);</span>
<span class="fc" id="L109">				} catch (ClassNotFoundException e) {</span>
<span class="fc" id="L110">					c = CACHED_CLASS_NOT_FOUND;</span>
				}
<span class="fc" id="L112">				classCache.put(className, c);</span>
			}
<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (c == CACHED_CLASS_NOT_FOUND) {</span>
<span class="fc" id="L115">				throw new ClassNotFoundException(className);</span>
			}
<span class="fc" id="L117">			return c;</span>
		}
	}

	public List&lt;Class&lt;?&gt;&gt; compile(File sourceDirectory) throws CompilationError {
<span class="fc" id="L122">		synchronized (compilationMutex) {</span>
<span class="fc" id="L123">			UID compilationIdentifier = new UID();</span>
<span class="fc" id="L124">			List&lt;JavaFileObject&gt; files = collectSourceFiles(compilationIdentifier, sourceDirectory, null);</span>
<span class="fc" id="L125">			return compile(compilationIdentifier, files.toArray(new JavaFileObject[files.size()]));</span>
		}
	}

	public Class&lt;?&gt; compile(String className, String source) throws CompilationError {
<span class="fc" id="L130">		synchronized (compilationMutex) {</span>
<span class="fc" id="L131">			ClassIdentifier classIdentifier = new ClassIdentifier(new UID(), className);</span>
<span class="fc" id="L132">			return compile(classIdentifier.getCompilationIdentifier(), sourceFile(classIdentifier, source, null))</span>
<span class="fc" id="L133">					.get(0);</span>
		}
	}

	private List&lt;Class&lt;?&gt;&gt; compile(UID compilationIdentifier, JavaFileObject... files) throws CompilationError {
<span class="fc" id="L138">		return compile(compilationIdentifier, Arrays.asList(files));</span>
	}

	private List&lt;Class&lt;?&gt;&gt; compile(UID compilationIdentifier, List&lt;JavaFileObject&gt; files) throws CompilationError {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">		if (Log.isVerbose()) {</span>
<span class="nc" id="L143">			Log.get()</span>
<span class="nc" id="L144">					.information(&quot;Compiling &quot; + files.stream()</span>
<span class="nc" id="L145">							.map(fileObject -&gt; ((NamedJavaFileObject) fileObject).getClassIdentifier().getClassName())</span>
<span class="nc" id="L146">							.collect(Collectors.toList()) + &quot;...&quot;);</span>
		}
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if (files.isEmpty())</span>
<span class="nc" id="L149">			throw new CompilationError(-1, -1, &quot;No input files&quot;, null, null);</span>
<span class="fc" id="L150">		synchronized (classCacheMutex) {</span>
<span class="fc" id="L151">			classCache.entrySet().removeIf(entry -&gt; {</span>
<span class="fc" id="L152">				String className = entry.getKey();</span>
<span class="fc" id="L153">				return files.stream()</span>
<span class="fc" id="L154">						.map(fileObject -&gt; ((NamedJavaFileObject) fileObject).getClassIdentifier().getClassName())</span>
<span class="fc" id="L155">						.anyMatch(newClassName -&gt; className.startsWith(newClassName));</span>
			});
		}
<span class="fc" id="L158">		try (JavaFileManager manager = createJavaFileManager()) {</span>
<span class="fc" id="L159">			DiagnosticCollector&lt;JavaFileObject&gt; collector = new DiagnosticCollector&lt;&gt;();</span>
			boolean success;
<span class="fc" id="L161">			List&lt;String&gt; finalOptions = new ArrayList&lt;String&gt;();</span>
			{
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">				if (options != null) {</span>
<span class="fc" id="L164">					options.forEach(finalOptions::add);</span>
				}
<span class="fc" id="L166">				String classpath = System.getProperty(&quot;java.class.path&quot;);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">				if (classpath == null) {</span>
<span class="nc" id="L168">					throw new UnexpectedError();</span>
				}
<span class="fc" id="L170">				URLClassLoader firstClassLoader = getFirstClassLoader();</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">				if (firstClassLoader != null) {</span>
<span class="fc" id="L172">					String parentClasspapth = Arrays.stream(firstClassLoader.getURLs()).map(url -&gt; {</span>
						try {
<span class="fc" id="L174">							return new File(url.toURI()).getAbsolutePath();</span>
<span class="nc" id="L175">						} catch (URISyntaxException e) {</span>
<span class="nc" id="L176">							throw new UnexpectedError(e);</span>
						}
<span class="fc" id="L178">					}).collect(Collectors.joining(File.pathSeparator));</span>
<span class="fc" id="L179">					classpath += File.pathSeparator + parentClasspapth;</span>
				}
<span class="fc" id="L181">				finalOptions.addAll(Arrays.asList(&quot;-classpath&quot;, classpath));</span>
			}
<span class="fc" id="L183">			CompilationTask task = compiler.getTask(null, manager, collector, finalOptions, null, files);</span>
<span class="fc" id="L184">			currentCompilationIdentifier = compilationIdentifier;</span>
			try {
<span class="fc" id="L186">				success = task.call();</span>
<span class="fc" id="L187">			} finally {</span>
<span class="fc" id="L188">				currentCompilationIdentifier = null;</span>
			}
<span class="fc" id="L190">			check(success, collector);</span>
<span class="nc" id="L191">		} catch (IOException e) {</span>
<span class="nc" id="L192">			throw new UnexpectedError(e);</span>
		}
<span class="fc" id="L194">		List&lt;Class&lt;?&gt;&gt; result = files.stream()</span>
<span class="fc" id="L195">				.map(f -&gt; new MemoryClassLoader(((NamedJavaFileObject) f).getClassIdentifier()))</span>
<span class="fc" id="L196">				.collect(Collectors.toList()).stream().map(classLoader -&gt; {</span>
					try {
<span class="fc" id="L198">						return classLoader.loadClass(classLoader.getMainClassIdentifier().className);</span>
<span class="nc" id="L199">					} catch (ClassNotFoundException e) {</span>
<span class="nc" id="L200">						throw new UnexpectedError(e);</span>
					}
<span class="fc" id="L202">				}).collect(Collectors.toList());</span>
<span class="fc" id="L203">		synchronized (classCacheMutex) {</span>
<span class="fc" id="L204">			result.stream().forEach(clazz -&gt; classCache.put(clazz.getName(), clazz));</span>
		}
<span class="fc" id="L206">		return result;</span>
	}

	private void check(boolean success, DiagnosticCollector&lt;?&gt; collector) throws CompilationError {
<span class="fc bfc" id="L210" title="All 2 branches covered.">		for (Diagnostic&lt;?&gt; diagnostic : collector.getDiagnostics()) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">			if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {</span>
<span class="fc" id="L212">				throw new CompilationError((int) diagnostic.getStartPosition(), (int) diagnostic.getEndPosition(),</span>
<span class="fc" id="L213">						diagnostic.getMessage(null), extractSourceFilePath(diagnostic), extractSourceCode(diagnostic));</span>
			}
		}
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">		if (!success) {</span>
<span class="nc" id="L217">			throw new CompilationError(-1, -1, &quot;Unknown error&quot;, null, null);</span>
		}
<span class="fc" id="L219">	}</span>

	private JavaFileManager createJavaFileManager() {
<span class="fc" id="L222">		return new ForwardingJavaFileManager&lt;JavaFileManager&gt;(</span>
<span class="fc" id="L223">				compiler.getStandardFileManager(null, null, Charset.defaultCharset())) {</span>
			@Override
			public JavaFileObject getJavaFileForOutput(Location loc, String className, Kind kind, FileObject obj) {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">				if (currentCompilationIdentifier == null) {</span>
<span class="nc" id="L227">					throw new UnexpectedError();</span>
				}
<span class="fc" id="L229">				return outputFile(new ClassIdentifier(currentCompilationIdentifier, className), kind, null);</span>
			}

			@Override
			public Iterable&lt;JavaFileObject&gt; list(Location loc, String pkg, Set&lt;Kind&gt; kinds, boolean rec)
					throws IOException {
<span class="fc" id="L235">				List&lt;JavaFileObject&gt; result = new ArrayList&lt;JavaFileObject&gt;();</span>
				Iterable&lt;JavaFileObject&gt; files;
<span class="fc" id="L237">				synchronized (classDataMutex) {</span>
<span class="fc" id="L238">					files = packagingMap.get(pkg);</span>
				}
<span class="fc bfc" id="L240" title="All 2 branches covered.">				if (files != null)</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">					for (JavaFileObject file : files)</span>
<span class="fc" id="L242">						result.add(file);</span>
<span class="fc" id="L243">				files = super.list(loc, pkg, kinds, rec);</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">				if (files != null)</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">					for (JavaFileObject file : files)</span>
<span class="fc" id="L246">						result.add(file);</span>
<span class="fc" id="L247">				return result;</span>
			}

			@Override
			public String inferBinaryName(Location loc, JavaFileObject file) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">				if (file instanceof NamedJavaFileObject)</span>
<span class="fc" id="L253">					return ((NamedJavaFileObject) file).getClassIdentifier().getClassName();</span>
				else
<span class="fc" id="L255">					return super.inferBinaryName(loc, file);</span>
			}
		};
	}

	private String extractSourceFilePath(Diagnostic&lt;?&gt; diagnostic) {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">		if (!(diagnostic.getSource() instanceof SimpleJavaFileObject)) {</span>
<span class="nc" id="L262">			return null;</span>
		}
<span class="fc" id="L264">		SimpleJavaFileObject javaFileObject = (SimpleJavaFileObject) diagnostic.getSource();</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">		if (javaFileObject.getKind() != Kind.SOURCE) {</span>
<span class="nc" id="L266">			return null;</span>
		}
<span class="fc" id="L268">		return javaFileObject.getName();</span>
	}

	private String extractSourceCode(Diagnostic&lt;?&gt; diagnostic) {
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">		if (!(diagnostic.getSource() instanceof SimpleJavaFileObject)) {</span>
<span class="nc" id="L273">			return null;</span>
		}
<span class="fc" id="L275">		SimpleJavaFileObject javaFileObject = (SimpleJavaFileObject) diagnostic.getSource();</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">		if (javaFileObject.getKind() != Kind.SOURCE) {</span>
<span class="nc" id="L277">			return null;</span>
		}
<span class="fc" id="L279">		try (Reader reader = javaFileObject.openReader(true)) {</span>
<span class="fc" id="L280">			return MiscUtils.read(new ReaderInputStream(reader, Charset.defaultCharset()));</span>
<span class="nc" id="L281">		} catch (IOException e) {</span>
<span class="nc" id="L282">			return null;</span>
		}
	}

	private List&lt;JavaFileObject&gt; collectSourceFiles(UID compilationIdentifier, File sourceDirectory,
			String currentPackageName) {
<span class="fc" id="L288">		List&lt;JavaFileObject&gt; result = new ArrayList&lt;JavaFileObject&gt;();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">		for (File fileOrDirectory : sourceDirectory.listFiles()) {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">			if (fileOrDirectory.isFile()) {</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">				if (fileOrDirectory.getName().endsWith(&quot;.java&quot;)) {</span>
<span class="fc" id="L292">					String className = fileOrDirectory.getName().substring(0,</span>
<span class="fc" id="L293">							fileOrDirectory.getName().length() - &quot;.java&quot;.length());</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">					if (currentPackageName != null) {</span>
<span class="fc" id="L295">						className = currentPackageName + &quot;.&quot; + className;</span>
					}
					String source;
<span class="fc" id="L298">					try (FileInputStream in = new FileInputStream(fileOrDirectory)) {</span>
<span class="fc" id="L299">						source = MiscUtils.read(in);</span>
<span class="nc" id="L300">					} catch (IOException e) {</span>
<span class="nc" id="L301">						throw new UnexpectedError(e);</span>
					}
<span class="fc" id="L303">					result.add(sourceFile(new ClassIdentifier(compilationIdentifier, className), source,</span>
<span class="fc" id="L304">							fileOrDirectory.toURI()));</span>
				}
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">			} else if (fileOrDirectory.isDirectory()) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">				String subPackageName = ((currentPackageName != null) ? (currentPackageName + &quot;.&quot;) : &quot;&quot;)</span>
<span class="fc" id="L308">						+ fileOrDirectory.getName();</span>
<span class="fc" id="L309">				result.addAll(collectSourceFiles(compilationIdentifier, fileOrDirectory, subPackageName));</span>
<span class="fc" id="L310">			} else {</span>
<span class="nc" id="L311">				throw new UnexpectedError();</span>
			}
		}
<span class="fc" id="L314">		return result;</span>
	}

	private static JavaFileObject sourceFile(ClassIdentifier classIdentifier, String source, URI uri) {
<span class="fc" id="L318">		return inputFile(classIdentifier, Kind.SOURCE, source, uri);</span>
	}

	private static JavaFileObject inputFile(ClassIdentifier classIdentifier, Kind kind, String content, URI uri) {
<span class="fc" id="L322">		return new NamedJavaFileObject(classIdentifier, kind, uri) {</span>
			@Override
			public CharSequence getCharContent(boolean b) {
<span class="fc" id="L325">				return content;</span>
			}
		};
	}

	private static NamedJavaFileObject inputFile(ClassIdentifier classIdentifier, Kind kind, byte[] content, URI uri) {
<span class="fc" id="L331">		return new NamedJavaFileObject(classIdentifier, kind, uri) {</span>
			@Override
			public InputStream openInputStream() {
<span class="fc" id="L334">				return new ByteArrayInputStream(content);</span>
			}
		};
	}

	private JavaFileObject outputFile(ClassIdentifier classIdentifier, Kind kind, URI uri) {
<span class="fc" id="L340">		return new NamedJavaFileObject(classIdentifier, kind, uri) {</span>
			@Override
			public OutputStream openOutputStream() {
<span class="fc" id="L343">				return outputStream(getClassIdentifier());</span>
			}
		};
	}

	private OutputStream outputStream(ClassIdentifier classIdentifier) {
<span class="fc" id="L349">		return new ByteArrayOutputStream() {</span>
<span class="fc" id="L350">			boolean closed = false;</span>

			@Override
			public void close() {
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">				if (closed) {</span>
<span class="nc" id="L355">					return;</span>
				}
<span class="fc" id="L357">				storeClass(classIdentifier, toByteArray());</span>
<span class="fc" id="L358">				closed = true;</span>
<span class="fc" id="L359">			}</span>
		};
	}

	private void storeClass(ClassIdentifier classIdentifier, byte[] bytes) {
<span class="fc" id="L364">		synchronized (classDataMutex) {</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">			if (classBinaries.containsKey(classIdentifier)) {</span>
<span class="nc" id="L366">				throw new UnexpectedError();</span>
			}
<span class="fc" id="L368">			classBinaries.put(classIdentifier, bytes);</span>
<span class="fc" id="L369">			NamedJavaFileObject file = inputFile(classIdentifier, Kind.CLASS, bytes, null);</span>
<span class="fc" id="L370">			int dot = classIdentifier.getClassName().lastIndexOf('.');</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">			String pkg = dot == -1 ? &quot;&quot; : classIdentifier.getClassName().substring(0, dot);</span>
<span class="fc" id="L372">			packagingMap.computeIfAbsent(pkg, k -&gt; new ArrayList&lt;&gt;()).add(0, file);</span>
		}
<span class="fc" id="L374">	}</span>

	private void unstoreClass(ClassIdentifier classIdentifier) {
<span class="fc" id="L377">		synchronized (classDataMutex) {</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">			if (!classBinaries.containsKey(classIdentifier)) {</span>
<span class="nc" id="L379">				throw new UnexpectedError();</span>
			}
<span class="fc" id="L381">			classBinaries.remove(classIdentifier);</span>
<span class="fc" id="L382">			int dot = classIdentifier.getClassName().lastIndexOf('.');</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">			String pkg = dot == -1 ? &quot;&quot; : classIdentifier.getClassName().substring(0, dot);</span>
<span class="fc" id="L384">			packagingMap.get(pkg)</span>
<span class="fc" id="L385">					.removeIf(file -&gt; ((NamedJavaFileObject) file).getClassIdentifier().equals(classIdentifier));</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">			if (packagingMap.get(pkg).size() == 0) {</span>
<span class="fc" id="L387">				packagingMap.remove(pkg);</span>
			}
		}
<span class="fc" id="L390">	}</span>

	private boolean shouldLoadThePackageFromMemory(String packageName) {
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">		return compiledClassesLoader.getClassLoaders().stream()</span>
<span class="fc bfc" id="L394" title="All 4 branches covered.">				.filter(l -&gt; (l instanceof MemoryClassLoader) &amp;&amp; !(l instanceof MemoryPackageLoader)</span>
<span class="fc" id="L395">						&amp;&amp; packageName.equals(MiscUtils.extractPackageNameFromClassName(</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">								((MemoryClassLoader) l).getMainClassIdentifier().getClassName())))</span>
<span class="fc" id="L397">				.count() &gt; 0;</span>
	}

	private static class ClassIdentifier {
		private final UID compilationIdentifier;
		private final String className;

<span class="fc" id="L404">		public ClassIdentifier(UID compilationIdentifier, String className) {</span>
<span class="fc" id="L405">			this.compilationIdentifier = compilationIdentifier;</span>
<span class="fc" id="L406">			this.className = className;</span>
<span class="fc" id="L407">		}</span>

		public UID getCompilationIdentifier() {
<span class="fc" id="L410">			return compilationIdentifier;</span>
		}

		public String getClassName() {
<span class="fc" id="L414">			return className;</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L419">			final int prime = 31;</span>
<span class="fc" id="L420">			int result = 1;</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">			result = prime * result + ((className == null) ? 0 : className.hashCode());</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">			result = prime * result + ((compilationIdentifier == null) ? 0 : compilationIdentifier.hashCode());</span>
<span class="fc" id="L423">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">			if (this == obj)</span>
<span class="nc" id="L429">				return true;</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">			if (obj == null)</span>
<span class="nc" id="L431">				return false;</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">			if (getClass() != obj.getClass())</span>
<span class="nc" id="L433">				return false;</span>
<span class="fc" id="L434">			ClassIdentifier other = (ClassIdentifier) obj;</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">			if (className == null) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">				if (other.className != null)</span>
<span class="nc" id="L437">					return false;</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">			} else if (!className.equals(other.className))</span>
<span class="fc" id="L439">				return false;</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">			if (compilationIdentifier == null) {</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">				if (other.compilationIdentifier != null)</span>
<span class="nc" id="L442">					return false;</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">			} else if (!compilationIdentifier.equals(other.compilationIdentifier))</span>
<span class="nc" id="L444">				return false;</span>
<span class="fc" id="L445">			return true;</span>
		}

	}

	private static class NamedJavaFileObject extends SimpleJavaFileObject {
		private final ClassIdentifier classIdentifier;

		protected NamedJavaFileObject(ClassIdentifier classIdentifier, Kind kind, URI uri) {
<span class="fc bfc" id="L454" title="All 2 branches covered.">			super((uri != null) ? uri : URI.create(classIdentifier.getClassName().replace('.', '/') + kind.extension),</span>
<span class="fc" id="L455">					kind);</span>
<span class="fc" id="L456">			this.classIdentifier = classIdentifier;</span>
<span class="fc" id="L457">		}</span>

		public ClassIdentifier getClassIdentifier() {
<span class="fc" id="L460">			return classIdentifier;</span>
		}
	}

	private class CompiledClassesLoader extends CompositeClassLoader {
<span class="fc" id="L465">		public CompiledClassesLoader() {</span>
<span class="fc" id="L466">			setFirstClassLoader(firstClassLoaderDelegator);</span>
<span class="fc" id="L467">		}</span>

		@SuppressWarnings(&quot;rawtypes&quot;)
		@Override
		protected Function&lt;ClassLoader, Class&gt; getClassLoadingFunction(String className, boolean resolve) {
<span class="fc" id="L472">			Function&lt;ClassLoader, Class&gt; baseFunction = super.getClassLoadingFunction(className, resolve);</span>
<span class="fc" id="L473">			return classLoader -&gt; {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">				if (classLoader instanceof MemoryClassLoader) {</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">					if (!((MemoryClassLoader) classLoader).isResponsibleForClass(className)) {</span>
<span class="fc" id="L476">						return null;</span>
					}
				}
<span class="fc" id="L479">				return baseFunction.apply(classLoader);</span>
			};
		}

		@Override
		protected Function&lt;ClassLoader, URL&gt; getResourceLoadingFunction(String name) {
<span class="fc" id="L485">			Function&lt;ClassLoader, URL&gt; baseFunction = super.getResourceLoadingFunction(name);</span>
<span class="fc" id="L486">			return classLoader -&gt; {</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">				if (classLoader instanceof MemoryClassLoader) {</span>
<span class="fc" id="L488">					return null;</span>
				}
<span class="fc" id="L490">				return baseFunction.apply(classLoader);</span>
			};
		}

	}

	private class MemoryClassLoader extends ClassLoader {
<span class="fc" id="L497">		private final List&lt;String&gt; definedClassNames = new ArrayList&lt;String&gt;();</span>
		private final ClassIdentifier mainClassIdentifier;

<span class="fc" id="L500">		public MemoryClassLoader(ClassIdentifier classIdentifier) {</span>
<span class="fc" id="L501">			super(compiledClassesLoader);</span>
<span class="fc" id="L502">			this.mainClassIdentifier = classIdentifier;</span>
<span class="fc" id="L503">			compiledClassesLoader.add(this);</span>
<span class="fc" id="L504">		}</span>

		public ClassIdentifier getMainClassIdentifier() {
<span class="fc" id="L507">			return mainClassIdentifier;</span>
		}

		@Override
		protected Package getPackage(String packageName) {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">			if (shouldLoadThePackageFromMemory(packageName)) {</span>
<span class="fc" id="L513">				MemoryPackageLoader responsiblePackageLoader = (MemoryPackageLoader) compiledClassesLoader</span>
<span class="fc" id="L514">						.getClassLoaders().stream()</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">						.filter(l -&gt; (l instanceof MemoryPackageLoader)</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">								&amp;&amp; ((MemoryPackageLoader) l).isResponsibleForPackage(packageName))</span>
<span class="fc" id="L517">						.findFirst().orElse(null);</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">				if (responsiblePackageLoader == null) {</span>
<span class="fc" id="L519">					responsiblePackageLoader = new MemoryPackageLoader(packageName);</span>
				}
<span class="fc" id="L521">				return responsiblePackageLoader.getPackage(packageName);</span>
			}
<span class="nc" id="L523">			return super.getPackage(packageName);</span>
		}

		@Override
		protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException {
<span class="fc" id="L528">			synchronized (getClassLoadingLock(className)) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">				if (isResponsibleForClass(className)) {</span>
					// First, check if the class has already been loaded
<span class="fc" id="L531">					Class&lt;?&gt; c = findLoadedClass(className);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">					if (c == null) {</span>
<span class="fc" id="L533">						c = findClass(className);</span>
					}
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">					if (resolve) {</span>
<span class="nc" id="L536">						resolveClass(c);</span>
					}
<span class="fc" id="L538">					return c;</span>
				} else {
<span class="fc" id="L540">					Class&lt;?&gt; c = compiledClassesLoader.loadClass(className);</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">					if (resolve) {</span>
<span class="nc" id="L542">						resolveClass(c);</span>
					}
<span class="fc" id="L544">					return c;</span>
				}
			}
		}

		protected boolean isResponsibleForClass(String className) {
<span class="fc bfc" id="L550" title="All 2 branches covered.">			return className.equals(mainClassIdentifier.getClassName())</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">					|| className.startsWith(mainClassIdentifier.getClassName() + &quot;$&quot;);</span>
		}

		@Override
		protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException {
			byte[] bytes;
<span class="fc" id="L557">			synchronized (classDataMutex) {</span>
<span class="fc" id="L558">				bytes = classBinaries</span>
<span class="fc" id="L559">						.get(new ClassIdentifier(mainClassIdentifier.getCompilationIdentifier(), className));</span>
			}
<span class="fc bfc" id="L561" title="All 2 branches covered.">			if (bytes == null)</span>
<span class="fc" id="L562">				throw new ClassNotFoundException(className);</span>
			try {
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">				if (firstClassLoaderDelegator.loadClass(className) != null) {</span>
<span class="fc" id="L565">					throw new UnexpectedError(</span>
<span class="fc" id="L566">							&quot;Cannot define a class that is already defined by the system class loader: &quot; + className);</span>
				}
<span class="fc" id="L568">			} catch (ClassNotFoundException e) {</span>
			}
<span class="fc" id="L570">			Class&lt;?&gt; result = super.defineClass(className, bytes, 0, bytes.length);</span>
<span class="fc" id="L571">			definedClassNames.add(className);</span>
<span class="fc" id="L572">			return result;</span>
		}

		@Override
		protected void finalize() throws Throwable {
<span class="fc bfc" id="L577" title="All 2 branches covered.">			for (String className : definedClassNames) {</span>
<span class="fc" id="L578">				unstoreClass(new ClassIdentifier(mainClassIdentifier.getCompilationIdentifier(), className));</span>
			}
<span class="fc" id="L580">			super.finalize();</span>
<span class="fc" id="L581">		}</span>

	}

	private class MemoryPackageLoader extends MemoryClassLoader {

		private final String thePackageName;
		private Package thePackage;
<span class="fc" id="L589">		private final Object packageCreationMutex = new Object();</span>
<span class="fc" id="L590">		private boolean definingThePackage = false;</span>

<span class="fc" id="L592">		public MemoryPackageLoader(String thePackageName) {</span>
<span class="fc" id="L593">			super(null);</span>
<span class="fc" id="L594">			this.thePackageName = thePackageName;</span>
<span class="fc" id="L595">		}</span>

		public boolean isResponsibleForPackage(String packageName) {
<span class="fc" id="L598">			return thePackageName.equals(packageName);</span>
		}

		@Override
		protected boolean isResponsibleForClass(String className) {
<span class="fc" id="L603">			return false;</span>
		}

		@Override
		protected Package getPackage(String packageName) {
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">			if (thePackageName.equals(packageName)) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">				if (definingThePackage) {</span>
<span class="fc" id="L610">					return null;</span>
				}
<span class="fc" id="L612">				synchronized (packageCreationMutex) {</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">					if (thePackage == null) {</span>
<span class="fc" id="L614">						definingThePackage = true;</span>
						try {
<span class="fc" id="L616">							thePackage = definePackage(packageName, null, null, null, null, null, null, null);</span>
<span class="fc" id="L617">						} finally {</span>
<span class="fc" id="L618">							definingThePackage = false;</span>
						}
					}
<span class="fc" id="L621">					return thePackage;</span>
				}
			}
<span class="nc" id="L624">			return super.getPackage(packageName);</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</div></body></html>