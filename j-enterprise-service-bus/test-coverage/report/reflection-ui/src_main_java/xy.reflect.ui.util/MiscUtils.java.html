<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>MiscUtils.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</a> &gt; <a href="../../index.html" class="el_group">reflection-ui</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">xy.reflect.ui.util</a> &gt; <span class="el_source">MiscUtils.java</span></div><h1>MiscUtils.java</h1><pre class="source lang-java linenums">/*
 * 
 */
package xy.reflect.ui.util;

import java.awt.Dimension;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.lang.ref.WeakReference;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.rmi.server.UID;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.regex.Pattern;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import xy.reflect.ui.ReflectionUI;
import xy.reflect.ui.control.swing.util.SwingRendererUtils;
import xy.reflect.ui.info.filter.IInfoFilter;

/**
 * Various utilities.
 * 
 * @author olitank
 *
 */
<span class="nc" id="L46">public class MiscUtils {</span>

<span class="fc" id="L48">	public static final String[] NEW_LINE_SEQUENCES = new String[] { &quot;\r\n&quot;, &quot;\n&quot;, &quot;\r&quot; };</span>
<span class="fc" id="L49">	public static final Pattern SPECIAL_REGEX_CHARS = Pattern.compile(&quot;[{}()\\[\\].+*?^$\\\\|]&quot;);</span>
<span class="fc" id="L50">	public static final Pattern SPECIAL_REGEX_REPLACEMENT_CHARS = Pattern.compile(&quot;[$\\\\]&quot;);</span>

	public static String escapeRegex(String str) {
<span class="fc" id="L53">		return SPECIAL_REGEX_CHARS.matcher(str).replaceAll(&quot;\\\\$0&quot;);</span>
	}

	public static String escapeRegexReplacement(String str) {
<span class="fc" id="L57">		return SPECIAL_REGEX_REPLACEMENT_CHARS.matcher(str).replaceAll(&quot;\\\\$0&quot;);</span>
	}

	public static &lt;T&gt; List&lt;T&gt; getAdded(Collection&lt;T&gt; baseItems, Collection&lt;T&gt; newItems) {
<span class="nc" id="L61">		List&lt;T&gt; result = new ArrayList&lt;T&gt;(baseItems);</span>
<span class="nc" id="L62">		result.addAll(newItems);</span>
<span class="nc" id="L63">		return result;</span>
	}

	public static &lt;T&gt; List&lt;T&gt; getReverse(List&lt;T&gt; ts) {
<span class="fc" id="L67">		List&lt;T&gt; result = new ArrayList&lt;T&gt;(ts);</span>
<span class="fc" id="L68">		Collections.reverse(result);</span>
<span class="fc" id="L69">		return result;</span>
	}

	public static &lt;BASE, C extends BASE&gt; List&lt;BASE&gt; convertCollection(Collection&lt;C&gt; ts) {
<span class="nc" id="L73">		List&lt;BASE&gt; result = new ArrayList&lt;BASE&gt;();</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">		for (C t : ts) {</span>
<span class="nc" id="L75">			result.add((BASE) t);</span>
		}
<span class="nc" id="L77">		return result;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;BASE, C extends BASE&gt; List&lt;C&gt; convertCollectionUnsafely(Collection&lt;BASE&gt; bs) {
<span class="fc" id="L82">		List&lt;C&gt; result = new ArrayList&lt;C&gt;();</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">		for (BASE b : bs) {</span>
<span class="fc" id="L84">			result.add((C) b);</span>
		}
<span class="fc" id="L86">		return result;</span>
	}

	public static boolean equalsOrBothNull(Object o1, Object o2) {
<span class="fc bfc" id="L90" title="All 2 branches covered.">		if (o1 == null) {</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">			return o2 == null;</span>
		} else {
<span class="fc" id="L93">			return o1.equals(o2);</span>
		}
	}

	public static String truncateNicely(String string, int maximumLength) {
<span class="fc bfc" id="L98" title="All 2 branches covered.">		if (string.length() &lt;= maximumLength) {</span>
<span class="fc" id="L99">			return string;</span>
		} else {
<span class="fc" id="L101">			return string.substring(0, maximumLength - 3) + &quot;...&quot;;</span>
		}
	}

	public static &lt;T&gt; Set&lt;T&gt; getIntersection(Set&lt;T&gt; s1, Set&lt;T&gt; s2) {
<span class="nc" id="L106">		HashSet&lt;T&gt; result = new HashSet&lt;T&gt;(s1);</span>
<span class="nc" id="L107">		result.retainAll(s2);</span>
<span class="nc" id="L108">		return result;</span>
	}

	public static &lt;K, V&gt; List&lt;K&gt; getKeysFromValue(Map&lt;K, V&gt; map, Object value) {
<span class="fc" id="L112">		List&lt;K&gt; result = new ArrayList&lt;K&gt;();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">		for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (MiscUtils.equalsOrBothNull(entry.getValue(), value)) {</span>
<span class="fc" id="L115">				result.add(entry.getKey());</span>
			}
		}
<span class="fc" id="L118">		return result;</span>
	}

	public static String changeCase(String string, boolean upperElseLower, int subStringStart, int subStringEnd) {
<span class="fc" id="L122">		String subString = string.substring(subStringStart, subStringEnd);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">		if (upperElseLower) {</span>
<span class="fc" id="L124">			subString = subString.toUpperCase();</span>
<span class="fc" id="L125">		} else {</span>
<span class="fc" id="L126">			subString = subString.toLowerCase();</span>
		}
<span class="fc" id="L128">		return string.substring(0, subStringStart) + subString + string.substring(subStringEnd);</span>
	}

	public static String[] splitLines(String s) {
<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (s.length() == 0) {</span>
<span class="nc" id="L133">			return new String[0];</span>
		}
<span class="nc" id="L135">		return s.split(getNewLineRegex(), -1);</span>
	}

	public static String getNewLineRegex() {
<span class="fc" id="L139">		return stringJoin(Arrays.asList(NEW_LINE_SEQUENCES), &quot;|&quot;);</span>
	}

	public static Object indentLines(String s, String tabulation) {
<span class="nc" id="L143">		String[] lines = splitLines(s);</span>
<span class="nc" id="L144">		StringBuilder result = new StringBuilder();</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">		for (int i = 0; i &lt; lines.length; i++) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">			if (i &gt; 0) {</span>
<span class="nc" id="L147">				result.append(&quot;\n&quot;);</span>
			}
<span class="nc" id="L149">			String line = lines[i];</span>
<span class="nc" id="L150">			result.append(tabulation + line);</span>
		}
<span class="nc" id="L152">		return result.toString();</span>
	}

	public static &lt;T&gt; String stringJoin(T[] array, String separator) {
<span class="nc" id="L156">		return stringJoin(Arrays.asList(array), separator);</span>
	}

	public static String stringJoin(List&lt;?&gt; list, String separator) {
<span class="fc" id="L160">		StringBuilder result = new StringBuilder();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">		for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="fc" id="L162">			Object item = list.get(i);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">			if (i &gt; 0) {</span>
<span class="fc" id="L164">				result.append(separator);</span>
			}
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">			if (item == null) {</span>
<span class="nc" id="L167">				result.append(&quot;null&quot;);</span>
<span class="nc" id="L168">			} else {</span>
<span class="fc" id="L169">				result.append(item.toString());</span>
			}
		}
<span class="fc" id="L172">		return result.toString();</span>
	}

	public static String escapeHTML(String string, boolean preserveNewLines) {
<span class="fc" id="L176">		StringBuffer sb = new StringBuffer(string.length());</span>
		// true if last char was blank
<span class="fc" id="L178">		boolean lastWasBlankChar = false;</span>
<span class="fc" id="L179">		int len = string.length();</span>
		char c;

<span class="fc bfc" id="L182" title="All 2 branches covered.">		for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L183">			c = string.charAt(i);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">			if (c == ' ') {</span>
				// blank gets extra work,
				// this solves the problem you get if you replace all
				// blanks with &amp;nbsp;, if you do that you loss
				// word breaking
<span class="fc bfc" id="L189" title="All 2 branches covered.">				if (lastWasBlankChar) {</span>
<span class="fc" id="L190">					lastWasBlankChar = false;</span>
<span class="fc" id="L191">					sb.append(&quot;&amp;nbsp;&quot;);</span>
<span class="fc" id="L192">				} else {</span>
<span class="fc" id="L193">					lastWasBlankChar = true;</span>
<span class="fc" id="L194">					sb.append(' ');</span>
				}
<span class="fc" id="L196">			} else {</span>
<span class="fc" id="L197">				lastWasBlankChar = false;</span>
				//
				// HTML Special Chars
<span class="fc bfc" id="L200" title="All 2 branches covered.">				if (c == '&quot;')</span>
<span class="fc" id="L201">					sb.append(&quot;&amp;quot;&quot;);</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">				else if (c == '&amp;')</span>
<span class="nc" id="L203">					sb.append(&quot;&amp;amp;&quot;);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">				else if (c == '&lt;')</span>
<span class="fc" id="L205">					sb.append(&quot;&amp;lt;&quot;);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">				else if (c == '&gt;')</span>
<span class="fc" id="L207">					sb.append(&quot;&amp;gt;&quot;);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">				else if (c == '\n')</span>
					// Handle Newline
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">					if (preserveNewLines) {</span>
<span class="fc" id="L211">						sb.append(&quot;&lt;br/&gt;&quot;);</span>
<span class="fc" id="L212">					} else {</span>
<span class="nc" id="L213">						sb.append(c);</span>
<span class="nc" id="L214">					}</span>
				else {
<span class="fc" id="L216">					int ci = 0xffff &amp; c;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">					if (ci &lt; 160)</span>
						// nothing special only 7 Bit
<span class="fc" id="L219">						sb.append(c);</span>
					else {
						// Not 7 Bit use the unicode system
<span class="fc" id="L222">						sb.append(&quot;&amp;#&quot;);</span>
<span class="fc" id="L223">						sb.append(new Integer(ci).toString());</span>
<span class="fc" id="L224">						sb.append(';');</span>
					}
				}
			}
		}
<span class="fc" id="L229">		return sb.toString();</span>
	}

	public static &lt;T extends Comparable&lt;T&gt;&gt; int compareNullables(T c1, T c2) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">		if (c1 == null) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">			if (c2 == null) {</span>
<span class="nc" id="L235">				return 0;</span>
			} else {
<span class="nc" id="L237">				return -1;</span>
			}
		} else {
<span class="nc bnc" id="L240" title="All 2 branches missed.">			if (c2 == null) {</span>
<span class="nc" id="L241">				return 1;</span>
			} else {
<span class="nc" id="L243">				return c1.compareTo(c2);</span>
			}
		}
	}

	public static StackTraceElement[] createDebugStackTrace(int firstElementsToRemove) {
<span class="nc" id="L249">		StackTraceElement[] result = new Exception().getStackTrace();</span>
<span class="nc" id="L250">		return Arrays.copyOfRange(result, 1 + firstElementsToRemove, result.length);</span>
	}

	public static &lt;T&gt; boolean replaceItem(List&lt;T&gt; list, T t1, T t2) {
<span class="fc" id="L254">		int index = list.indexOf(t1);</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">		if (index == -1) {</span>
<span class="nc" id="L256">			return false;</span>
		}
<span class="fc" id="L258">		list.set(index, t2);</span>
<span class="fc" id="L259">		return true;</span>
	}

	public static String getUniqueID() {
<span class="nc" id="L263">		return new UID().toString();</span>
	}

	public static Dimension getDefaultScreenSize() {
<span class="nc" id="L267">		GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();</span>
<span class="nc" id="L268">		Rectangle maximumBounds = SwingRendererUtils.getMaximumWindowBounds(gd);</span>
<span class="nc" id="L269">		return maximumBounds.getSize();</span>
	}

	public static String multiToSingleLine(String s) {
<span class="fc" id="L273">		return s.replaceAll(&quot;\\r\\n|\\n|\\r&quot;, &quot; &quot;);</span>
	}

	public static &lt;K, V&gt; K getFirstKeyFromValue(Map&lt;K, V&gt; map, V value) {
<span class="fc" id="L277">		List&lt;K&gt; list = getKeysFromValue(map, value);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">		if (list.size() &gt; 0) {</span>
<span class="fc" id="L279">			return list.get(0);</span>
		}
<span class="fc" id="L281">		return null;</span>
	}

	public static String getPrintedStackTrace(Throwable e) {
<span class="fc" id="L285">		ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L286">		e.printStackTrace(new PrintStream(out));</span>
<span class="fc" id="L287">		return out.toString();</span>
	}

	public static String getPrettyErrorMessage(Throwable t) {
<span class="fc" id="L291">		return new ReflectionUIError(t).toString();</span>
	}

	public static ExecutorService newExecutor(final String threadName, int minimumThreadCount) {
<span class="fc" id="L295">		ThreadPoolExecutor result = new ThreadPoolExecutor(minimumThreadCount, Integer.MAX_VALUE,</span>
<span class="fc" id="L296">				SystemProperties.getExecutorIdleTimeoutSeconds(), TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(),</span>
<span class="fc" id="L297">				new ThreadFactory() {</span>
<span class="fc" id="L298">					private int threadNumber = 0;</span>

					@Override
					public Thread newThread(Runnable r) {
<span class="fc" id="L302">						Thread result = new Thread(r);</span>
<span class="fc" id="L303">						result.setName(threadName + &quot;-&quot; + (threadNumber++));</span>
<span class="fc" id="L304">						result.setDaemon(true);</span>
<span class="fc" id="L305">						return result;</span>
					}
				});
<span class="fc" id="L308">		result.allowCoreThreadTimeOut(true);</span>
<span class="fc" id="L309">		return result;</span>
	}

	public static &lt;K, V&gt; Map&lt;K, V&gt; newWeakKeysIdentityBasedMap() {
<span class="fc" id="L313">		return new WeakHashMap&lt;K, V&gt;();</span>
	}

	public static &lt;K, V&gt; Map&lt;K, V&gt; newWeakValuesEqualityBasedMap() {
<span class="nc" id="L317">		return newAutoCleanUpCache(false, true, -1, -1, null, 5000, &quot;WeakValuesEqualityBasedMapCleaner&quot;);</span>
	}

	public static &lt;K, V&gt; Map&lt;K, V&gt; newWeakKeysIdentityBasedCache(int maxSize) {
<span class="nc" id="L321">		return newAutoCleanUpCache(true, false, maxSize, -1, null, 5000, &quot;WeakKeysIdentityBasedCacheCleaner&quot;);</span>
	}

	public static &lt;K, V&gt; Map&lt;K, V&gt; newStandardCache(boolean expiration) {
<span class="fc" id="L325">		return newAutoCleanUpCache(false, false, SystemProperties.getStandardCacheSize(),</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">				expiration ? SystemProperties.getStandardCacheExpirationDelaySeconds() : -1, TimeUnit.SECONDS, 5000,</span>
<span class="fc" id="L327">				&quot;StandardCacheCleaner&quot;);</span>
	}

	public static &lt;K, V&gt; Map&lt;K, V&gt; newAutoCleanUpCache(boolean weakKeys, boolean weakValues, long maxSize,
			long expirationDuration, TimeUnit expirationDurationUnit, final long cleanUpPeriodMilliseconds,
			String cleanUpThreadNamePrefix) {
<span class="fc" id="L333">		CacheBuilder&lt;Object, Object&gt; builder = CacheBuilder.newBuilder();</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">		if (maxSize != -1) {</span>
<span class="fc" id="L335">			builder = builder.maximumSize(maxSize);</span>
		}
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">		if (weakKeys) {</span>
<span class="nc" id="L338">			builder = builder.weakKeys();</span>
		}
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">		if (weakValues) {</span>
<span class="nc" id="L341">			builder = builder.weakValues();</span>
		}
<span class="fc bfc" id="L343" title="All 2 branches covered.">		if (expirationDuration &gt; 0) {</span>
<span class="fc" id="L344">			builder = builder.expireAfterAccess(expirationDuration, expirationDurationUnit);</span>
		}
<span class="fc" id="L346">		Cache&lt;K, V&gt; cache = builder.&lt;K, V&gt;build();</span>
<span class="fc" id="L347">		Map&lt;K, V&gt; map = cache.asMap();</span>
<span class="fc" id="L348">		final WeakReference&lt;Map&lt;K, V&gt;&gt; mapWeakRef = new WeakReference&lt;Map&lt;K, V&gt;&gt;(map);</span>
<span class="fc" id="L349">		new Thread(cleanUpThreadNamePrefix + &quot; [cache=&quot; + cache + &quot;, maxSize=&quot; + maxSize + &quot;]&quot;) {</span>
			{
<span class="fc" id="L351">				setDaemon(true);</span>
			}

			@Override
			public void run() {
				while (true) {
					try {
<span class="fc" id="L358">						Thread.sleep(cleanUpPeriodMilliseconds);</span>
<span class="pc" id="L359">					} catch (InterruptedException e) {</span>
<span class="nc" id="L360">						throw new ReflectionUIError(e);</span>
					}
<span class="fc" id="L362">					Map&lt;K, V&gt; map = mapWeakRef.get();</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">					if (map == null) {</span>
<span class="fc" id="L364">						break;</span>
					}
					try {
<span class="fc" id="L367">						Method cleanUpMethod = map.getClass().getMethod(&quot;cleanUp&quot;);</span>
<span class="fc" id="L368">						cleanUpMethod.setAccessible(true);</span>
<span class="fc" id="L369">						cleanUpMethod.invoke(map);</span>
<span class="pc" id="L370">					} catch (InvocationTargetException e) {</span>
<span class="nc" id="L371">						throw new ReflectionUIError(e.getTargetException());</span>
<span class="nc" id="L372">					} catch (Exception e) {</span>
<span class="nc" id="L373">						throw new ReflectionUIError(e);</span>
					}
				}
<span class="fc" id="L376">			}</span>
<span class="fc" id="L377">		}.start();</span>
<span class="fc" id="L378">		return map;</span>
	}

	public static boolean isHTMLText(String text) {
<span class="fc" id="L382">		return Pattern.compile(&quot;\\s*&lt;[hH][tT][mM][lL]&gt;.*&lt;/[hH][tT][mM][lL]&gt;\\s*&quot;, Pattern.DOTALL).matcher(text)</span>
<span class="fc" id="L383">				.matches();</span>
	}

	public static &lt;T&gt; Set&lt;T&gt; getFilteredSet(Set&lt;T&gt; set, Predicate&lt;T&gt; filter) {
<span class="nc bnc" id="L387" title="All 2 branches missed.">		if (set == null) {</span>
<span class="nc" id="L388">			return null;</span>
		}
<span class="nc" id="L390">		Set&lt;T&gt; result = new HashSet&lt;T&gt;();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">		for (T node : set) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">			if (filter.test(node)) {</span>
<span class="nc" id="L393">				result.add(node);</span>
			}
		}
<span class="nc" id="L396">		return result;</span>
	}

	public static &lt;T&gt; Set&lt;T&gt; inferNewNonFilteredSet(Set&lt;T&gt; oldSet, Predicate&lt;T&gt; filter, Set&lt;T&gt; newFilteredSet) {
<span class="nc bnc" id="L400" title="All 2 branches missed.">		if (newFilteredSet == null) {</span>
<span class="nc" id="L401">			return null;</span>
		}
<span class="nc" id="L403">		Set&lt;T&gt; oldFilteredNodes = getFilteredSet(oldSet, filter);</span>
<span class="nc" id="L404">		Set&lt;T&gt; result = new HashSet&lt;T&gt;();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">		if (oldSet != null) {</span>
<span class="nc" id="L406">			result.addAll(oldSet);</span>
		}
<span class="nc" id="L408">		Set&lt;T&gt; addedNodes = new HashSet&lt;T&gt;(newFilteredSet);</span>
<span class="nc" id="L409">		addedNodes.removeAll(oldFilteredNodes);</span>
<span class="nc" id="L410">		result.addAll(addedNodes);</span>
<span class="nc" id="L411">		Set&lt;T&gt; removedNodes = new HashSet&lt;T&gt;(oldFilteredNodes);</span>
<span class="nc" id="L412">		removedNodes.removeAll(newFilteredSet);</span>
<span class="nc" id="L413">		result.removeAll(removedNodes);</span>
<span class="nc" id="L414">		return result;</span>
	}

	public static boolean containsWord(String text, String word) {
<span class="fc" id="L418">		return text.matches(&quot;.*\\b&quot; + escapeRegex(word) + &quot;\\b.*&quot;);</span>
	}

	public static String replaceWord(String text, String word, String replacement) {
<span class="fc" id="L422">		return text.replaceAll(&quot;\\b&quot; + escapeRegex(word) + &quot;\\b&quot;, escapeRegexReplacement(replacement));</span>
	}

	public static boolean sameExceptionOrBothNull(Throwable error1, Throwable error2, ReflectionUI reflectionUI)
			throws Exception {
<span class="fc bfc" id="L427" title="All 2 branches covered.">		if (error1 == null) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">			return error2 == null;</span>
		}
<span class="fc bfc" id="L430" title="All 2 branches covered.">		if (error2 == null) {</span>
<span class="fc" id="L431">			return false;</span>
		}
<span class="fc bfc" id="L433" title="All 2 branches covered.">		if (!ReflectionUIUtils.equalsAccordingInfos(error1, error2, reflectionUI, IInfoFilter.DEFAULT)) {</span>
<span class="fc" id="L434">			return false;</span>
		}
<span class="fc" id="L436">		return true;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</div></body></html>