<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ClassUtils.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</a> &gt; <a href="../../index.html" class="el_group">reflection-ui</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">xy.reflect.ui.util</a> &gt; <span class="el_source">ClassUtils.java</span></div><h1>ClassUtils.java</h1><pre class="source lang-java linenums">
package xy.reflect.ui.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Utilities for dealing with classes.
 * 
 * @author olitank
 *
 */
<span class="nc" id="L23">public class ClassUtils {</span>

<span class="fc" id="L25">	public static final Class&lt;?&gt;[] PRIMITIVE_CLASSES = new Class&lt;?&gt;[] { boolean.class, byte.class, short.class,</span>
<span class="fc" id="L26">			int.class, long.class, float.class, double.class, char.class };</span>
<span class="fc" id="L27">	public static final Class&lt;?&gt;[] PRIMITIVE_WRAPPER_CLASSES = new Class&lt;?&gt;[] { Boolean.class, Byte.class, Short.class,</span>
<span class="fc" id="L28">			Integer.class, Long.class, Float.class, Double.class, Character.class };</span>

<span class="fc" id="L30">	public static final Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVE_CLASS_BY_NAME = new HashMap&lt;String, Class&lt;?&gt;&gt;() {</span>
		private static final long serialVersionUID = 1L;
		{
<span class="fc bfc" id="L33" title="All 2 branches covered.">			for (Class&lt;?&gt; c : PRIMITIVE_CLASSES) {</span>
<span class="fc" id="L34">				put(c.getName(), c);</span>
			}
		}
	};

	protected static boolean DEFAULT_BOOLEAN;
	protected static byte DEFAULT_BYTE;
	protected static short DEFAULT_SHORT;
	protected static int DEFAULT_INT;
	protected static long DEFAULT_LONG;
	protected static float DEFAULT_FLOAT;
	protected static double DEFAULT_DOUBLE;
<span class="fc" id="L46">	protected static char DEFAULT_CHAR;</span>

	
	

	

	public static Class&lt;?&gt; forNameEvenIfPrimitive(String name) throws ClassNotFoundException {
<span class="fc" id="L54">		Class&lt;?&gt; result = PRIMITIVE_CLASS_BY_NAME.get(name);</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L56">			return result;</span>
		}
<span class="fc" id="L58">		result = Class.forName(name);</span>
<span class="fc" id="L59">		return result;</span>
	}

	

	public static Class&lt;?&gt; primitiveToWrapperClass(Class&lt;?&gt; class1) {
<span class="fc" id="L65">		int index = Arrays.asList(PRIMITIVE_CLASSES).indexOf(class1);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">		if (index == -1) {</span>
<span class="fc" id="L67">			return null;</span>
		}
<span class="fc" id="L69">		return PRIMITIVE_WRAPPER_CLASSES[index];</span>
	}

	public static Class&lt;?&gt; wrapperToPrimitiveClass(Class&lt;?&gt; class1) {
<span class="fc" id="L73">		int index = Arrays.asList(PRIMITIVE_WRAPPER_CLASSES).indexOf(class1);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">		if (index == -1) {</span>
<span class="fc" id="L75">			return null;</span>
		}
<span class="fc" id="L77">		return PRIMITIVE_CLASSES[index];</span>
	}

	public static boolean isPrimitiveClassOrWrapperOrString(Class&lt;?&gt; class1) {
<span class="fc bfc" id="L81" title="All 4 branches covered.">		return (class1 == String.class) || isPrimitiveClassOrWrapper(class1);</span>
	}

	public static boolean isPrimitiveClassOrWrapper(Class&lt;?&gt; class1) {
<span class="fc bfc" id="L85" title="All 4 branches covered.">		return isPrimitiveClass(class1) || isPrimitiveWrapperClass(class1);</span>
	}

	public static boolean isPrimitiveClass(Class&lt;?&gt; class1) {
<span class="fc bfc" id="L89" title="All 2 branches covered.">		return primitiveToWrapperClass(class1) != null;</span>
	}

	public static boolean isPrimitiveWrapperClass(Class&lt;?&gt; class1) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">		return wrapperToPrimitiveClass(class1) != null;</span>
	}

	public static Object getDefaultPrimitiveValue(Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">		if (clazz.equals(boolean.class)) {</span>
<span class="fc" id="L98">			return DEFAULT_BOOLEAN;</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">		} else if (clazz.equals(byte.class)) {</span>
<span class="nc" id="L100">			return DEFAULT_BYTE;</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">		} else if (clazz.equals(short.class)) {</span>
<span class="nc" id="L102">			return DEFAULT_SHORT;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">		} else if (clazz.equals(int.class)) {</span>
<span class="fc" id="L104">			return DEFAULT_INT;</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">		} else if (clazz.equals(long.class)) {</span>
<span class="fc" id="L106">			return DEFAULT_LONG;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">		} else if (clazz.equals(float.class)) {</span>
<span class="nc" id="L108">			return DEFAULT_FLOAT;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">		} else if (clazz.equals(double.class)) {</span>
<span class="nc" id="L110">			return DEFAULT_DOUBLE;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">		} else if (clazz.equals(char.class)) {</span>
<span class="nc" id="L112">			return DEFAULT_CHAR;</span>
		} else {
<span class="nc" id="L114">			throw new IllegalArgumentException(&quot;Class '&quot; + clazz + &quot;' is not a valid primitive wrapper class&quot;);</span>
		}
	}

	public static boolean isKnownAsImmutableClass(Class&lt;?&gt; class1) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">		if (isPrimitiveClassOrWrapperOrString(class1)) {</span>
<span class="fc" id="L120">			return true;</span>
		}
<span class="fc" id="L122">		return false;</span>
	}

	public static List&lt;Class&lt;?&gt;&gt; getAncestorClasses(Class&lt;?&gt; type) {
<span class="nc" id="L126">		List&lt;Class&lt;?&gt;&gt; result = new ArrayList&lt;Class&lt;?&gt;&gt;();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">		while (type.getSuperclass() != null) {</span>
<span class="nc" id="L128">			result.add(type.getSuperclass());</span>
<span class="nc" id="L129">			type = type.getSuperclass();</span>
		}
<span class="nc" id="L131">		return result;</span>
	}

	public static Set&lt;Class&lt;?&gt;&gt; getAncestorClassesAndInterfaces(Class&lt;?&gt; type) {
<span class="nc" id="L135">		Set&lt;Class&lt;?&gt;&gt; result = new HashSet&lt;Class&lt;?&gt;&gt;();</span>
<span class="nc" id="L136">		List&lt;Class&lt;?&gt;&gt; ancestorClasses = getAncestorClasses(type);</span>
<span class="nc" id="L137">		result.addAll(ancestorClasses);</span>
<span class="nc" id="L138">		result.addAll(getSuperInterfaces(type.getInterfaces()));</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">		for (Class&lt;?&gt; ancestor : ancestorClasses) {</span>
<span class="nc" id="L140">			result.addAll(getSuperInterfaces(ancestor.getInterfaces()));</span>
		}
<span class="nc" id="L142">		return result;</span>
	}

	public static Set&lt;Class&lt;?&gt;&gt; getSuperInterfaces(Class&lt;?&gt;[] childInterfaces) {
<span class="nc" id="L146">		Set&lt;Class&lt;?&gt;&gt; allInterfaces = new HashSet&lt;Class&lt;?&gt;&gt;();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		for (int i = 0; i &lt; childInterfaces.length; i++) {</span>
<span class="nc" id="L148">			allInterfaces.add(childInterfaces[i]);</span>
<span class="nc" id="L149">			allInterfaces.addAll(getSuperInterfaces(childInterfaces[i].getInterfaces()));</span>
		}
<span class="nc" id="L151">		return allInterfaces;</span>
	}

	public static List&lt;String&gt; gatClassNames(Class&lt;?&gt;[] classes) {
<span class="nc" id="L155">		List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">		for (Class&lt;?&gt; clazz : classes) {</span>
<span class="nc" id="L157">			result.add(clazz.getName());</span>
		}
<span class="nc" id="L159">		return result;</span>
	}

	public static Set&lt;Class&lt;?&gt;&gt; getAncestorsAndSelfClassesAndInterfaces(Class&lt;?&gt; type) {
<span class="nc" id="L163">		Set&lt;Class&lt;?&gt;&gt; result = new HashSet&lt;Class&lt;?&gt;&gt;(getAncestorClassesAndInterfaces(type));</span>
<span class="nc" id="L164">		result.add(type);</span>
<span class="nc" id="L165">		return result;</span>
	}

	public static List&lt;Parameter&gt; getJavaParameters(Method javaMethod) {
<span class="nc" id="L169">		List&lt;Parameter&gt; result = new ArrayList&lt;Parameter&gt;();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">		for (Parameter parameter : javaMethod.getParameters()) {</span>
<span class="nc" id="L171">			result.add(parameter);</span>
		}
<span class="nc" id="L173">		return Arrays.asList(javaMethod.getParameters());</span>
	}

	public static List&lt;Parameter&gt; getJavaParameters(Constructor&lt;?&gt; ctor) {
<span class="nc" id="L177">		List&lt;Parameter&gt; result = new ArrayList&lt;Parameter&gt;();</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">		for (Parameter parameter : ctor.getParameters()) {</span>
<span class="nc" id="L179">			result.add(parameter);</span>
		}
<span class="nc" id="L181">		return result;</span>
	}

	public static List&lt;Field&gt; getAllFields(Class&lt;?&gt; type) {
<span class="nc" id="L185">		List&lt;Field&gt; result = new ArrayList&lt;Field&gt;();</span>
<span class="nc" id="L186">		Class&lt;?&gt; currentType = type;</span>
<span class="nc bnc" id="L187" title="All 4 branches missed.">		while (currentType != null &amp;&amp; currentType != Object.class) {</span>
<span class="nc" id="L188">			result.addAll(Arrays.asList(currentType.getDeclaredFields()));</span>
<span class="nc" id="L189">			currentType = currentType.getSuperclass();</span>
		}
<span class="nc" id="L191">		return result;</span>
	}

	public static boolean isJavaClassMainMethod(Method javaMethod) {
<span class="fc bfc" id="L195" title="All 2 branches covered.">		if (Modifier.isStatic(javaMethod.getModifiers())) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">			if (javaMethod.getReturnType().equals(void.class)) {</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">				if (javaMethod.getName().equals(&quot;main&quot;)) {</span>
<span class="fc" id="L198">					Class&lt;?&gt;[] paramTypes = javaMethod.getParameterTypes();</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">					if (paramTypes.length == 1) {</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">						if (paramTypes[0].equals(String[].class)) {</span>
<span class="fc" id="L201">							return true;</span>
						}
					}
				}
			}
		}
<span class="fc" id="L207">		return false;</span>
	}

	public static String getQualifiedName(Field field) {
<span class="nc" id="L211">		return field.getDeclaringClass().getName() + &quot;#&quot; + field.getName();</span>
	}

	public static String getQualifiedName(Method method) {
<span class="nc" id="L215">		return method.getDeclaringClass().getName() + &quot;#&quot; + method.getName() + &quot;(&quot;</span>
<span class="nc" id="L216">				+ MiscUtils.stringJoin(gatClassNames(method.getParameterTypes()), &quot;,&quot;) + &quot;)&quot;;</span>
	}

	public static String getQualifiedName(Constructor&lt;?&gt; constructor) {
<span class="nc" id="L220">		return constructor.getDeclaringClass().getName() + &quot;#&quot; + constructor.getName() + &quot;(&quot;</span>
<span class="nc" id="L221">				+ MiscUtils.stringJoin(gatClassNames(constructor.getParameterTypes()), &quot;,&quot;) + &quot;)&quot;;</span>
	}

	public static boolean isOverriddenBy(Method baseMethod, Method overridingMethod) {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">		if (!baseMethod.getDeclaringClass().isAssignableFrom(overridingMethod.getDeclaringClass())) {</span>
<span class="nc" id="L226">			return false;</span>
		}
<span class="fc bfc" id="L228" title="All 2 branches covered.">		if (!baseMethod.getName().equals(overridingMethod.getName())) {</span>
<span class="fc" id="L229">			return false;</span>
		}
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">		if (!baseMethod.getReturnType().isAssignableFrom(overridingMethod.getReturnType())) {</span>
<span class="nc" id="L232">			return false;</span>
		}
<span class="fc" id="L234">		Class&lt;?&gt;[] baseMethodParamTypes = baseMethod.getParameterTypes();</span>
<span class="fc" id="L235">		Class&lt;?&gt;[] overridingMethodParamTypes = overridingMethod.getParameterTypes();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">		if (baseMethodParamTypes.length != overridingMethodParamTypes.length) {</span>
<span class="fc" id="L237">			return false;</span>
		}
<span class="fc bfc" id="L239" title="All 2 branches covered.">		for (int iParam = 0; iParam &lt; baseMethodParamTypes.length; iParam++) {</span>
<span class="fc" id="L240">			Class&lt;?&gt; baseMethodParamType = baseMethodParamTypes[iParam];</span>
<span class="fc" id="L241">			Class&lt;?&gt; overridingMethodParamType = overridingMethodParamTypes[iParam];</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">			if (!baseMethodParamType.isAssignableFrom(overridingMethodParamType)) {</span>
<span class="nc" id="L243">				return false;</span>
			}
		}
<span class="fc" id="L246">		return true;</span>
	}

	public static Class&lt;?&gt; getAnonymousClassBase(Class&lt;?&gt; clazz) {
<span class="nc" id="L250">		Class&lt;?&gt; superClass = clazz.getSuperclass();</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">		if ((superClass != null) &amp;&amp; (superClass != Object.class)) {</span>
<span class="nc" id="L252">			return superClass;</span>
		}
<span class="nc" id="L254">		Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (interfaces.length == 1) {</span>
<span class="nc" id="L256">			return interfaces[0];</span>
		}
<span class="nc" id="L258">		return superClass;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</div></body></html>