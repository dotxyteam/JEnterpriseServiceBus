<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ListControl.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</a> &gt; <a href="../../index.html" class="el_group">reflection-ui</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">xy.reflect.ui.control.swing</a> &gt; <span class="el_source">ListControl.java</span></div><h1>ListControl.java</h1><pre class="source lang-java linenums">
package xy.reflect.ui.control.swing;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;
import java.util.concurrent.ExecutorService;
import java.util.stream.Collectors;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.BorderFactory;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.JTree;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreePath;

import org.jdesktop.swingx.JXTreeTable;
import org.jdesktop.swingx.treetable.AbstractTreeTableModel;
import org.jdesktop.swingx.treetable.TreeTableModel;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;

import xy.reflect.ui.control.BufferedFieldControlData;
import xy.reflect.ui.control.CustomContext;
import xy.reflect.ui.control.DefaultFieldControlData;
import xy.reflect.ui.control.DefaultMethodControlData;
import xy.reflect.ui.control.ErrorHandlingFieldControlData;
import xy.reflect.ui.control.IAdvancedFieldControl;
import xy.reflect.ui.control.IContext;
import xy.reflect.ui.control.IFieldControlData;
import xy.reflect.ui.control.IFieldControlInput;
import xy.reflect.ui.control.IMethodControlData;
import xy.reflect.ui.control.IMethodControlInput;
import xy.reflect.ui.control.MethodContext;
import xy.reflect.ui.control.swing.ListControl.IItemsVisitor.VisitStatus;
import xy.reflect.ui.control.swing.builder.AbstractEditorBuilder;
import xy.reflect.ui.control.swing.renderer.FieldControlPlaceHolder;
import xy.reflect.ui.control.swing.renderer.Form;
import xy.reflect.ui.control.swing.renderer.SwingRenderer;
import xy.reflect.ui.control.swing.util.AbstractControlButton;
import xy.reflect.ui.control.swing.util.AbstractLazyTreeNode;
import xy.reflect.ui.control.swing.util.ControlPanel;
import xy.reflect.ui.control.swing.util.ControlScrollPane;
import xy.reflect.ui.control.swing.util.ControlSplitPane;
import xy.reflect.ui.control.swing.util.ScrollPaneOptions;
import xy.reflect.ui.control.swing.util.SwingRendererUtils;
import xy.reflect.ui.info.ValidationSession;
import xy.reflect.ui.info.ValueReturnMode;
import xy.reflect.ui.info.field.IFieldInfo;
import xy.reflect.ui.info.filter.IInfoFilter;
import xy.reflect.ui.info.menu.MenuModel;
import xy.reflect.ui.info.method.InvocationData;
import xy.reflect.ui.info.type.ITypeInfo;
import xy.reflect.ui.info.type.ITypeInfo.IValidationJob;
import xy.reflect.ui.info.type.factory.FieldAlternativeListItemConstructorsInstaller;
import xy.reflect.ui.info.type.iterable.IListTypeInfo;
import xy.reflect.ui.info.type.iterable.IListTypeInfo.ItemCreationMode;
import xy.reflect.ui.info.type.iterable.item.AbstractBufferedItemPositionFactory;
import xy.reflect.ui.info.type.iterable.item.BufferedItemPosition;
import xy.reflect.ui.info.type.iterable.item.IListItemDetailsAccessMode;
import xy.reflect.ui.info.type.iterable.item.ItemDetailsAreaPosition;
import xy.reflect.ui.info.type.iterable.item.ItemPosition;
import xy.reflect.ui.info.type.iterable.item.BufferedItemPositionFactory;
import xy.reflect.ui.info.type.iterable.item.EmbeddedItemDetailsAccessMode;
import xy.reflect.ui.info.type.iterable.structure.IListStructuralInfo;
import xy.reflect.ui.info.type.iterable.structure.column.IColumnInfo;
import xy.reflect.ui.info.type.iterable.util.IDynamicListAction;
import xy.reflect.ui.info.type.iterable.util.IDynamicListFeauture.DisplayMode;
import xy.reflect.ui.info.type.iterable.util.IDynamicListProperty;
import xy.reflect.ui.info.type.source.ITypeInfoSource;
import xy.reflect.ui.info.type.source.JavaTypeInfoSource;
import xy.reflect.ui.undo.AbstractModification;
import xy.reflect.ui.undo.FieldControlDataModification;
import xy.reflect.ui.undo.IModification;
import xy.reflect.ui.undo.ListModificationFactory;
import xy.reflect.ui.undo.MethodControlDataModification;
import xy.reflect.ui.undo.ModificationStack;
import xy.reflect.ui.undo.UndoOrder;
import xy.reflect.ui.util.Accessor;
import xy.reflect.ui.util.Filter;
import xy.reflect.ui.util.Listener;
import xy.reflect.ui.util.Mapper;
import xy.reflect.ui.util.MiscUtils;
import xy.reflect.ui.util.ReflectionUIError;
import xy.reflect.ui.util.ReflectionUIUtils;
import xy.reflect.ui.util.SystemProperties;
import xy.reflect.ui.util.ValidationErrorWrapper;

/**
 * Field control that displays a tree table. Compatible with
 * {@link IListTypeInfo}.
 * 
 * REMARK: A distinction is made between physical selection changes, which
 * consist of changes to the paths of selected nodes, and logical selection
 * changes, which consist of changes to the set of elements behind the selected
 * nodes. Only logical selection changes generate events available through the
 * listeners registered in the {@link #selectionListeners} list.
 * 
 * @author olitank
 *
 */
public class ListControl extends ControlPanel implements IAdvancedFieldControl {

	protected static final long serialVersionUID = 1L;

	protected SwingRenderer swingRenderer;
	protected BufferedFieldControlData listData;

	protected JXTreeTable treeTableComponent;
	protected JScrollPane treeTableComponentScrollPane;
	protected JPanel toolbar;
	protected ItemNode rootNode;
	protected AbstractBufferedItemPositionFactory itemPositionFactory;
<span class="fc" id="L164">	protected static List&lt;Object&gt; clipboard = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L165">	protected Map&lt;ItemNode, Map&lt;Integer, String&gt;&gt; valuesByNode = new HashMap&lt;ItemNode, Map&lt;Integer, String&gt;&gt;();</span>
<span class="fc" id="L166">	protected ExecutorService itemValidationErrorsCollectingExecutor = MiscUtils</span>
<span class="fc" id="L167">			.newExecutor(&quot;ListValidationErrorsCollector&quot;, 0);</span>

	protected JPanel detailsArea;
	protected Form detailsControl;
	protected ItemUIBuilder detailsControlBuilder;
	protected IListItemDetailsAccessMode detailsMode;
	protected BufferedItemPosition detailsControlItemPosition;

<span class="fc" id="L175">	protected List&lt;Listener&lt;List&lt;BufferedItemPosition&gt;&gt;&gt; selectionListeners = new ArrayList&lt;Listener&lt;List&lt;BufferedItemPosition&gt;&gt;&gt;();</span>
<span class="fc" id="L176">	protected boolean selectionListenersEnabled = true;</span>
	protected IFieldControlInput input;

	protected IFieldControlData selectionTargetData;
<span class="fc" id="L180">	protected boolean selectionTargetListenerEnabled = true;</span>

<span class="fc" id="L182">	protected static AbstractAction SEPARATOR_ACTION = new AbstractAction(&quot;&quot;) {</span>
		protected static final long serialVersionUID = 1L;

		@Override
		public void actionPerformed(ActionEvent e) {
<span class="nc" id="L187">		}</span>
<span class="fc" id="L188">	};</span>
<span class="fc" id="L189">	protected boolean buffersRefreshedAfterModification = false;</span>
<span class="fc" id="L190">	protected boolean initialized = false;</span>

<span class="fc" id="L192">	public ListControl(final SwingRenderer swingRenderer, IFieldControlInput input) {</span>
<span class="fc" id="L193">		this.swingRenderer = swingRenderer;</span>
<span class="fc" id="L194">		this.input = input;</span>
<span class="fc" id="L195">		this.listData = new BufferedFieldControlData(</span>
<span class="fc" id="L196">				new ErrorHandlingFieldControlData(input.getControlData(), swingRenderer, ListControl.this));</span>
<span class="fc" id="L197">		listData.returningValue(listData.getValue(), new Runnable() {</span>
			@Override
			public void run() {
<span class="fc" id="L200">				initializeTreeTableModelAndControl();</span>
<span class="fc" id="L201">				toolbar = new ControlPanel();</span>
<span class="fc" id="L202">				detailsArea = new ControlPanel();</span>

<span class="fc" id="L204">				displayDetailsOnItemDoubleClick();</span>
<span class="fc" id="L205">				updatePartsOnSelectionChange();</span>
<span class="fc" id="L206">				updateSelectionTargetOnSelectionChange();</span>
<span class="fc" id="L207">				handleMouseRightButton();</span>
<span class="fc" id="L208">				updateToolbar();</span>
<span class="fc" id="L209">				initializeSelectionListening();</span>
<span class="fc" id="L210">				refreshUI(true);</span>
<span class="fc" id="L211">				setDefaultSelection();</span>
<span class="fc" id="L212">			}</span>
		});
<span class="fc" id="L214">		this.initialized = true;</span>
<span class="fc" id="L215">	}</span>

	protected void setDefaultSelection() {
<span class="fc bfc" id="L218" title="All 4 branches covered.">		if (getSelection().isEmpty() &amp;&amp; (getRootListSize() &gt; 0)) {</span>
<span class="fc" id="L219">			setSingleSelection(getRootListItemPosition(0));</span>
		}
<span class="fc" id="L221">	}</span>

	@Override
	public void updateUI() {
<span class="fc" id="L225">		super.updateUI();</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">		if (initialized) {</span>
<span class="nc" id="L227">			refreshUI(true);</span>
		}
<span class="fc" id="L229">	}</span>

	public IFieldControlData getSelectionTargetData() {
<span class="fc" id="L232">		return selectionTargetData;</span>
	}

	public void setSelectionTargetData(IFieldControlData selectionTargetData) {
<span class="fc" id="L236">		this.selectionTargetData = selectionTargetData;</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">		if (selectionTargetData != null) {</span>
<span class="fc" id="L238">			Object selectionTargetDataValue = selectionTargetData.getValue();</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">			BufferedItemPosition itemPosition = (selectionTargetDataValue != null)</span>
<span class="nc" id="L240">					? findFirstItemPositionByValue(selectionTargetDataValue)</span>
<span class="fc" id="L241">					: null;</span>
<span class="fc" id="L242">			withoutSelectionTargetListenerEnabled(new Runnable() {</span>
				@Override
				public void run() {
<span class="fc" id="L245">					setSingleSelection(itemPosition);</span>
<span class="fc" id="L246">				}</span>
			});
		}
<span class="fc" id="L249">	}</span>

	public boolean areBuffersRefreshedAfterModification() {
<span class="nc" id="L252">		return buffersRefreshedAfterModification;</span>
	}

	public void setBuffersRefreshedAfterModification(boolean buffersRefreshedAfterModification) {
<span class="nc" id="L256">		this.buffersRefreshedAfterModification = buffersRefreshedAfterModification;</span>
<span class="nc" id="L257">	}</span>

	public Object getRootListValue() {
<span class="nc" id="L260">		return itemPositionFactory.getRootListValue();</span>
	}

	public String getRootListTitle() {
<span class="fc" id="L264">		return listData.getCaption();</span>
	}

	protected void updatePartsOnSelectionChange() {
<span class="fc" id="L268">		selectionListeners.add(new Listener&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
			@Override
			public void handle(List&lt;BufferedItemPosition&gt; event) {
<span class="fc" id="L271">				updateDetailsArea(true);</span>
<span class="fc" id="L272">				updateToolbar();</span>
<span class="fc" id="L273">			}</span>
		});
<span class="fc" id="L275">	}</span>

	protected void layoutControls() {
<span class="fc" id="L278">		setLayout(new BorderLayout());</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">		if (getDetailsAccessMode().hasEmbeddedDetailsDisplayArea()) {</span>
<span class="fc" id="L280">			JPanel listAndToolbarPanel = new ControlPanel();</span>
<span class="fc" id="L281">			listAndToolbarPanel.setLayout(new BorderLayout());</span>
<span class="fc" id="L282">			listAndToolbarPanel.add(BorderLayout.CENTER, treeTableComponentScrollPane);</span>
<span class="fc" id="L283">			String toolbarConstraint = getToolbarBorderLayoutConstraint();</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">			if (toolbarConstraint != null) {</span>
<span class="fc" id="L285">				listAndToolbarPanel.add(toolbar, getToolbarBorderLayoutConstraint());</span>
			}
<span class="fc" id="L287">			ControlScrollPane listAndToolbarScrollPane = createTreeTableAndToolBarScrollPane(listAndToolbarPanel);</span>
<span class="fc" id="L288">			SwingRendererUtils.removeScrollPaneBorder(listAndToolbarScrollPane);</span>
<span class="fc" id="L289">			ControlScrollPane detailsAreaScrollPane = createDetailsAreaScrollPane(detailsArea);</span>
<span class="fc" id="L290">			JSplitPane splitPane = new ControlSplitPane();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">			if (listData.getBorderColor() != null) {</span>
<span class="fc" id="L292">				splitPane.setBorder(</span>
<span class="fc" id="L293">						BorderFactory.createLineBorder(SwingRendererUtils.getColor(listData.getBorderColor())));</span>
			}
<span class="fc" id="L295">			add(splitPane, BorderLayout.CENTER);</span>
			final double dividerLocation;
<span class="fc bfc" id="L297" title="All 2 branches covered.">			if (getDetailsAccessMode().getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.RIGHT) {</span>
<span class="fc" id="L298">				splitPane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);</span>
<span class="fc" id="L299">				splitPane.setLeftComponent(listAndToolbarScrollPane);</span>
<span class="fc" id="L300">				splitPane.setRightComponent(detailsAreaScrollPane);</span>
<span class="fc" id="L301">				dividerLocation = 1.0 - getDetailsAccessMode().getDefaultEmbeddedDetailsAreaOccupationRatio();</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">			} else if (getDetailsAccessMode().getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.LEFT) {</span>
<span class="nc" id="L303">				splitPane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);</span>
<span class="nc" id="L304">				splitPane.setRightComponent(listAndToolbarScrollPane);</span>
<span class="nc" id="L305">				splitPane.setLeftComponent(detailsAreaScrollPane);</span>
<span class="nc" id="L306">				dividerLocation = getDetailsAccessMode().getDefaultEmbeddedDetailsAreaOccupationRatio();</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">			} else if (getDetailsAccessMode().getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.BOTTOM) {</span>
<span class="fc" id="L308">				splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);</span>
<span class="fc" id="L309">				splitPane.setTopComponent(listAndToolbarScrollPane);</span>
<span class="fc" id="L310">				splitPane.setBottomComponent(detailsAreaScrollPane);</span>
<span class="fc" id="L311">				dividerLocation = 1.0 - getDetailsAccessMode().getDefaultEmbeddedDetailsAreaOccupationRatio();</span>
<span class="pc bnc" id="L312" title="All 2 branches missed.">			} else if (getDetailsAccessMode().getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.TOP) {</span>
<span class="nc" id="L313">				splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);</span>
<span class="nc" id="L314">				splitPane.setBottomComponent(listAndToolbarScrollPane);</span>
<span class="nc" id="L315">				splitPane.setTopComponent(detailsAreaScrollPane);</span>
<span class="nc" id="L316">				dividerLocation = getDetailsAccessMode().getDefaultEmbeddedDetailsAreaOccupationRatio();</span>
<span class="nc" id="L317">			} else {</span>
<span class="nc" id="L318">				throw new ReflectionUIError();</span>
			}
<span class="fc" id="L320">			SwingRendererUtils.ensureDividerLocation(splitPane, dividerLocation);</span>
<span class="fc" id="L321">			splitPane.setResizeWeight(dividerLocation);</span>
<span class="fc" id="L322">		} else {</span>
<span class="fc" id="L323">			add(treeTableComponentScrollPane, BorderLayout.CENTER);</span>
<span class="fc" id="L324">			add(toolbar, BorderLayout.EAST);</span>
		}
<span class="fc" id="L326">	}</span>

	protected String getToolbarBorderLayoutConstraint() {
<span class="fc" id="L329">		IListTypeInfo.ToolsLocation toolsLocation = getRootListType().getToolsLocation();</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">		if (toolsLocation == IListTypeInfo.ToolsLocation.NORTH) {</span>
<span class="nc" id="L331">			return BorderLayout.NORTH;</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">		} else if (toolsLocation == IListTypeInfo.ToolsLocation.SOUTH) {</span>
<span class="nc" id="L333">			return BorderLayout.SOUTH;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">		} else if (toolsLocation == IListTypeInfo.ToolsLocation.EAST) {</span>
<span class="fc" id="L335">			return BorderLayout.EAST;</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">		} else if (toolsLocation == IListTypeInfo.ToolsLocation.WEST) {</span>
<span class="fc" id="L337">			return BorderLayout.WEST;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">		} else if (toolsLocation == IListTypeInfo.ToolsLocation.HIDDEN) {</span>
<span class="nc" id="L339">			return null;</span>
		} else {
<span class="nc" id="L341">			throw new ReflectionUIError();</span>
		}
	}

	protected void updateToolbar() {
<span class="fc" id="L346">		toolbar.removeAll();</span>
<span class="fc" id="L347">		String toolbarConstraint = getToolbarBorderLayoutConstraint();</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">		if (toolbarConstraint == null) {</span>
<span class="nc" id="L349">			return;</span>
		}
<span class="fc" id="L351">		GridBagLayout layout = new GridBagLayout();</span>
<span class="fc" id="L352">		toolbar.setLayout(layout);</span>

<span class="fc bfc" id="L354" title="All 2 branches covered.">		if (getDetailsAccessMode().hasDetachedDetailsDisplayOption()) {</span>
<span class="fc" id="L355">			AbstractStandardListAction openAction = createOpenItemAction();</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">			if (openAction.isValid()) {</span>
<span class="fc" id="L357">				toolbar.add(createTool(null, SwingRendererUtils.DETAILS_ICON, true, false, openAction));</span>
			}
		}

<span class="fc" id="L361">		AbstractStandardListAction addChildAction = createAddChildAction();</span>
<span class="fc" id="L362">		AbstractStandardListAction insertAction = createInsertAction(InsertPosition.UNKNOWN);</span>
<span class="fc" id="L363">		AbstractStandardListAction insertActionBefore = createInsertAction(InsertPosition.BEFORE);</span>
<span class="fc" id="L364">		AbstractStandardListAction insertActionAfter = createInsertAction(InsertPosition.AFTER);</span>
<span class="fc" id="L365">		toolbar.add(createTool(null, SwingRendererUtils.ADD_ICON, false, false, addChildAction, insertAction,</span>
<span class="fc" id="L366">				insertActionBefore, insertActionAfter));</span>
<span class="fc" id="L367">		toolbar.add(createTool(null, SwingRendererUtils.REMOVE_ICON, false, false, createRemoveAction()));</span>
<span class="fc" id="L368">		AbstractStandardListAction moveUpAction = createMoveAction(-1);</span>
<span class="fc" id="L369">		AbstractStandardListAction moveDownAction = createMoveAction(1);</span>
<span class="fc bfc" id="L370" title="All 4 branches covered.">		if (moveUpAction.isValid() || moveDownAction.isValid()) {</span>
<span class="fc" id="L371">			toolbar.add(createTool(null, SwingRendererUtils.UP_ICON, true, false, moveUpAction));</span>
<span class="fc" id="L372">			toolbar.add(createTool(null, SwingRendererUtils.DOWN_ICON, true, false, moveDownAction));</span>
		}

<span class="fc" id="L375">		Mapper&lt;ItemPosition, ListModificationFactory&gt; modificationFactoryAccessor = new Mapper&lt;ItemPosition, ListModificationFactory&gt;() {</span>
			@Override
			public ListModificationFactory get(ItemPosition itemPosition) {
<span class="fc" id="L378">				return createListModificationFactory((BufferedItemPosition) itemPosition);</span>
			}
		};
<span class="fc" id="L381">		List&lt;IDynamicListProperty&gt; dynamicProperties = getRootListType().getDynamicProperties(getSelection(),</span>
<span class="fc" id="L382">				modificationFactoryAccessor);</span>
<span class="fc" id="L383">		List&lt;IDynamicListAction&gt; dynamicActions = getRootListType().getDynamicActions(getSelection(),</span>
<span class="fc" id="L384">				modificationFactoryAccessor);</span>
<span class="fc bfc" id="L385" title="All 4 branches covered.">		if ((dynamicProperties.size() &gt; 0) || (dynamicActions.size() &gt; 0)) {</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">			for (IDynamicListProperty listProperty : dynamicProperties) {</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">				if ((listProperty.getDisplayMode() == DisplayMode.TOOLBAR)</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">						|| (listProperty.getDisplayMode() == DisplayMode.TOOLBAR_AND_CONTEXT_MENU)) {</span>
<span class="fc" id="L389">					AbstractStandardListAction dynamicPropertyHook = createDynamicPropertyHook(listProperty);</span>
<span class="fc" id="L390">					toolbar.add(createTool((String) dynamicPropertyHook.getActionTitle(), null, true, false,</span>
<span class="fc" id="L391">							dynamicPropertyHook));</span>
				}
			}
<span class="fc bfc" id="L394" title="All 2 branches covered.">			for (IDynamicListAction listAction : dynamicActions) {</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">				if ((listAction.getDisplayMode() == DisplayMode.TOOLBAR)</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">						|| (listAction.getDisplayMode() == DisplayMode.TOOLBAR_AND_CONTEXT_MENU)) {</span>
<span class="fc" id="L397">					AbstractStandardListAction dynamicActionHook = createDynamicActionHook(listAction);</span>
<span class="fc" id="L398">					toolbar.add(createTool((String) dynamicActionHook.getActionTitle(),</span>
<span class="fc" id="L399">							(Icon) dynamicActionHook.getValue(AbstractAction.LARGE_ICON_KEY), true, false,</span>
<span class="fc" id="L400">							dynamicActionHook));</span>
				}
			}
		}

<span class="fc bfc" id="L405" title="All 2 branches covered.">		for (int i = 0; i &lt; toolbar.getComponentCount(); i++) {</span>
<span class="fc" id="L406">			Component c = toolbar.getComponent(i);</span>
<span class="fc" id="L407">			GridBagConstraints constraints = new GridBagConstraints();</span>
<span class="pc bpc" id="L408" title="1 of 4 branches missed.">			if (toolbarConstraint.equals(BorderLayout.WEST) || toolbarConstraint.equals(BorderLayout.EAST)) {</span>
<span class="fc" id="L409">				constraints.gridx = 0;</span>
<span class="fc" id="L410">				constraints.fill = GridBagConstraints.HORIZONTAL;</span>
<span class="fc" id="L411">				constraints.insets = new Insets(1, 5, 1, 5);</span>
<span class="pc bnc" id="L412" title="All 4 branches missed.">			} else if (toolbarConstraint.equals(BorderLayout.NORTH) || toolbarConstraint.equals(BorderLayout.SOUTH)) {</span>
<span class="nc" id="L413">				constraints.gridy = 0;</span>
<span class="nc" id="L414">				constraints.fill = GridBagConstraints.VERTICAL;</span>
<span class="nc" id="L415">				constraints.insets = new Insets(5, 1, 5, 1);</span>
<span class="nc" id="L416">			} else {</span>
<span class="nc" id="L417">				throw new ReflectionUIError();</span>
			}
<span class="fc" id="L419">			layout.setConstraints(c, constraints);</span>
		}

<span class="fc" id="L422">		JSeparator filler = new JSeparator(JSeparator.VERTICAL);</span>
		{
<span class="fc" id="L424">			GridBagConstraints constraints = new GridBagConstraints();</span>
<span class="pc bpc" id="L425" title="1 of 4 branches missed.">			if (toolbarConstraint.equals(BorderLayout.WEST) || toolbarConstraint.equals(BorderLayout.EAST)) {</span>
<span class="fc" id="L426">				constraints.gridx = 0;</span>
<span class="fc" id="L427">				constraints.weighty = 1;</span>
<span class="pc bnc" id="L428" title="All 4 branches missed.">			} else if (toolbarConstraint.equals(BorderLayout.NORTH) || toolbarConstraint.equals(BorderLayout.SOUTH)) {</span>
<span class="nc" id="L429">				constraints.gridy = 0;</span>
<span class="nc" id="L430">				constraints.weightx = 1;</span>
<span class="nc" id="L431">			} else {</span>
<span class="nc" id="L432">				throw new ReflectionUIError();</span>
			}
<span class="fc" id="L434">			toolbar.add(filler, constraints);</span>
		}

<span class="fc" id="L437">		SwingRendererUtils.handleComponentSizeChange(ListControl.this);</span>
<span class="fc" id="L438">		toolbar.validate();</span>
<span class="fc" id="L439">		toolbar.repaint();</span>
<span class="fc" id="L440">	}</span>

	protected JButton createTool(final String caption, final Icon icon, boolean alwawsShowIcon,
			final boolean alwawsShowMenu, AbstractStandardListAction... actions) {
<span class="fc" id="L444">		final List&lt;AbstractStandardListAction&gt; actionsToPresent = new ArrayList&lt;AbstractStandardListAction&gt;();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">		for (final AbstractStandardListAction action : actions) {</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">			if (action == null) {</span>
<span class="nc" id="L447">				continue;</span>
			}
<span class="fc bfc" id="L449" title="All 2 branches covered.">			if (action.isEnabled()) {</span>
<span class="fc" id="L450">				actionsToPresent.add(action);</span>
			}
		}
<span class="fc" id="L453">		final JButton result = new AbstractControlButton() {</span>

			private static final long serialVersionUID = 1L;

			@Override
			public Image retrieveBackgroundImage() {
<span class="fc bfc" id="L459" title="All 2 branches covered.">				if (listData.getButtonBackgroundImagePath() == null) {</span>
<span class="fc" id="L460">					return null;</span>
				} else {
<span class="fc" id="L462">					return SwingRendererUtils.loadImageThroughCache(listData.getButtonBackgroundImagePath(),</span>
<span class="fc" id="L463">							ReflectionUIUtils.getErrorLogListener(swingRenderer.getReflectionUI()), swingRenderer);</span>
				}
			}

			@Override
			public Font retrieveCustomFont() {
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">				if (listData.getButtonCustomFontResourcePath() == null) {</span>
<span class="fc" id="L470">					return null;</span>
				} else {
<span class="nc" id="L472">					return SwingRendererUtils.loadFontThroughCache(listData.getButtonCustomFontResourcePath(),</span>
<span class="nc" id="L473">							ReflectionUIUtils.getErrorLogListener(swingRenderer.getReflectionUI()), swingRenderer);</span>
				}
			}

			@Override
			public Color retrieveBackgroundColor() {
<span class="fc bfc" id="L479" title="All 2 branches covered.">				if (listData.getButtonBackgroundColor() == null) {</span>
<span class="fc" id="L480">					return null;</span>
				} else {
<span class="fc" id="L482">					return SwingRendererUtils.getColor(listData.getButtonBackgroundColor());</span>
				}
			}

			@Override
			public Color retrieveForegroundColor() {
<span class="fc bfc" id="L488" title="All 2 branches covered.">				if (listData.getButtonForegroundColor() == null) {</span>
<span class="fc" id="L489">					return null;</span>
				} else {
<span class="fc" id="L491">					return SwingRendererUtils.getColor(listData.getButtonForegroundColor());</span>
				}
			}

			@Override
			public Color retrieveBorderColor() {
<span class="fc bfc" id="L497" title="All 2 branches covered.">				if (listData.getButtonBorderColor() == null) {</span>
<span class="fc" id="L498">					return null;</span>
				} else {
<span class="fc" id="L500">					return SwingRendererUtils.getColor(listData.getButtonBorderColor());</span>
				}
			}

			@Override
			public Icon retrieveIcon() {
<span class="fc" id="L506">				return icon;</span>
			}

			@Override
			public String retrieveText() {
<span class="fc" id="L511">				return swingRenderer.prepareMessageToDisplay(caption);</span>
			}

			@Override
			public String retrieveToolTipText() {
<span class="fc bfc" id="L516" title="All 2 branches covered.">				if (actionsToPresent.size() &gt; 0) {</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">					if (actionsToPresent.size() == 1) {</span>
<span class="fc" id="L518">						String tooltipText = (String) actionsToPresent.get(0).getActionDescription();</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">						if (tooltipText == null) {</span>
<span class="fc" id="L520">							tooltipText = (String) actionsToPresent.get(0).getActionTitle();</span>
						}
<span class="fc" id="L522">						return swingRenderer.prepareMessageToDisplay(tooltipText);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">					} else if (actionsToPresent.size() &gt; 1) {</span>
<span class="fc" id="L524">						StringBuilder tooltipTextBuilder = new StringBuilder();</span>
<span class="fc" id="L525">						boolean firstAction = true;</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">						for (AbstractStandardListAction action : actionsToPresent) {</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">							if (!firstAction) {</span>
<span class="fc" id="L528">								tooltipTextBuilder.append(&quot;\nor\n&quot;);</span>
							}
<span class="fc" id="L530">							String itemTooltipText = (String) action.getActionDescription();</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">							if (itemTooltipText == null) {</span>
<span class="fc" id="L532">								itemTooltipText = (String) action.getActionTitle();</span>
							}
<span class="fc" id="L534">							tooltipTextBuilder.append(itemTooltipText);</span>
<span class="fc" id="L535">							firstAction = false;</span>
						}
<span class="fc" id="L537">						return swingRenderer.prepareMessageToDisplay(tooltipTextBuilder.toString());</span>
					} else {
<span class="nc" id="L539">						return null;</span>
					}
				} else {
<span class="fc" id="L542">					return null;</span>
				}
			}

		};

<span class="fc bfc" id="L548" title="All 2 branches covered.">		if (actionsToPresent.size() &gt; 0) {</span>
<span class="fc" id="L549">			result.addActionListener(new ActionListener() {</span>
				@Override
				public void actionPerformed(ActionEvent e) {
<span class="pc bpc" id="L552" title="1 of 4 branches missed.">					if (!alwawsShowMenu &amp;&amp; (actionsToPresent.size() == 1)) {</span>
<span class="fc" id="L553">						actionsToPresent.get(0).actionPerformed(null);</span>
<span class="fc" id="L554">					} else {</span>
<span class="fc" id="L555">						final JPopupMenu popupMenu = new JPopupMenu();</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">						for (AbstractAction action : actionsToPresent) {</span>
<span class="fc" id="L557">							popupMenu.add(action);</span>
						}
<span class="fc" id="L559">						popupMenu.show(result, result.getWidth(), result.getHeight());</span>
					}
<span class="fc" id="L561">				}</span>
			});
<span class="fc" id="L563">		} else {</span>
<span class="fc" id="L564">			result.setEnabled(false);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">			if (!alwawsShowIcon) {</span>
<span class="fc" id="L566">				result.setVisible(false);</span>
			}
		}
<span class="fc" id="L569">		return result;</span>
	}

	protected void handleMouseRightButton() {
<span class="fc" id="L573">		treeTableComponent.addMouseListener(new MouseAdapter() {</span>

			@Override
			public void mouseReleased(MouseEvent e) {
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">				if (e.getButton() != MouseEvent.BUTTON3) {</span>
<span class="nc" id="L578">					return;</span>
				}
<span class="fc" id="L580">				adjustSelection(e);</span>
<span class="fc" id="L581">				popupMenu(e);</span>
<span class="fc" id="L582">			}</span>

			void adjustSelection(MouseEvent e) {
<span class="fc" id="L585">				int row = treeTableComponent.rowAtPoint(e.getPoint());</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">				if (treeTableComponent.isRowSelected(row)) {</span>
<span class="nc" id="L587">					return;</span>
				}
<span class="pc bpc" id="L589" title="3 of 4 branches missed.">				if ((row &lt; 0) || (row &gt;= treeTableComponent.getRowCount())) {</span>
<span class="fc" id="L590">					return;</span>
				}
<span class="nc" id="L592">				treeTableComponent.setRowSelectionInterval(row, row);</span>
<span class="nc" id="L593">				return;</span>
			}

			void popupMenu(MouseEvent e) {
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">				if (e.getComponent() == treeTableComponent) {</span>
<span class="fc" id="L598">					JPopupMenu popup = createPopupMenu();</span>
<span class="fc" id="L599">					popup.show(e.getComponent(), e.getX(), e.getY());</span>
<span class="fc" id="L600">					return;</span>
				}
<span class="nc" id="L602">			}</span>

		});
<span class="fc" id="L605">	}</span>

	protected JPopupMenu createPopupMenu() {
<span class="fc" id="L608">		JPopupMenu result = new JPopupMenu();</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">		for (Action action : getCurrentSelectionActions()) {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">			if (action == SEPARATOR_ACTION) {</span>
<span class="fc" id="L611">				result.add(new JSeparator());</span>
<span class="fc" id="L612">				continue;</span>
			}
<span class="fc" id="L614">			JMenuItem menuItem = new JMenuItem(action);</span>
<span class="fc" id="L615">			result.add(menuItem);</span>
		}
<span class="fc" id="L617">		return result;</span>
	}

	@Override
	public boolean displayError(Throwable error) {
<span class="nc" id="L622">		return false;</span>
	}

	@Override
	public boolean isModificationStackManaged() {
<span class="fc" id="L627">		return true;</span>
	}

	@Override
	public boolean areValueAccessErrorsManaged() {
<span class="fc" id="L632">		return true;</span>
	}

	public IListStructuralInfo getRootStructuralInfo() {
<span class="fc" id="L636">		return getStructuralInfo(getRootListItemPosition(-1));</span>
	}

	public IListStructuralInfo getStructuralInfo(BufferedItemPosition itemPosition) {
<span class="fc" id="L640">		IListTypeInfo listType = itemPosition.getContainingListType();</span>
<span class="fc" id="L641">		IListStructuralInfo result = listType.getStructuralInfo();</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L643">			throw new ReflectionUIError(&quot;No &quot; + IListStructuralInfo.class.getSimpleName() + &quot; found on the type '&quot;</span>
<span class="nc" id="L644">					+ listType.getName() + &quot;'&quot;);</span>
		}
<span class="fc" id="L646">		return result;</span>
	}

	public IListItemDetailsAccessMode getDetailsAccessMode() {
<span class="fc bfc" id="L650" title="All 2 branches covered.">		if (detailsMode == null) {</span>
<span class="fc" id="L651">			IListTypeInfo listType = getRootListType();</span>
<span class="fc" id="L652">			detailsMode = listType.getDetailsAccessMode();</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">			if (detailsMode == null) {</span>
<span class="nc" id="L654">				throw new ReflectionUIError(&quot;No &quot; + IListItemDetailsAccessMode.class.getSimpleName()</span>
<span class="nc" id="L655">						+ &quot; found on the type '&quot; + listType.getName());</span>
			}
		}
<span class="fc" id="L658">		return detailsMode;</span>
	}

	protected void initializeTreeTableModelAndControl() {
<span class="fc" id="L662">		itemPositionFactory = createItemPositionfactory();</span>
<span class="fc" id="L663">		rootNode = createRootNode();</span>
<span class="fc" id="L664">		treeTableComponent = createTreeTable();</span>
<span class="fc" id="L665">		treeTableComponentScrollPane = createTreeTableScrollPane(treeTableComponent);</span>
<span class="fc" id="L666">		treeTableComponent.setExpandsSelectedPaths(true);</span>
<span class="fc" id="L667">		treeTableComponent.getSelectionModel().setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);</span>
<span class="fc" id="L668">		treeTableComponent.setRootVisible(false);</span>
<span class="fc" id="L669">		treeTableComponent.setShowsRootHandles(true);</span>
<span class="fc" id="L670">		treeTableComponent.setDefaultRenderer(Object.class, createTableCellRenderer());</span>
<span class="fc" id="L671">		treeTableComponent.setTreeCellRenderer(createTreeCellRenderer());</span>
<span class="fc" id="L672">		treeTableComponent.setColumnMargin(5);</span>
<span class="fc" id="L673">		treeTableComponent.getTableHeader().setReorderingAllowed(false);</span>
<span class="fc" id="L674">		treeTableComponent.setHorizontalScrollEnabled(true);</span>
<span class="fc" id="L675">		treeTableComponent.addTreeExpansionListener(new TreeExpansionListener() {</span>
			@Override
			public void treeExpanded(TreeExpansionEvent event) {
<span class="fc" id="L678">				SwingUtilities.invokeLater(new Runnable() {</span>
					@Override
					public void run() {
<span class="fc" id="L681">						SwingRendererUtils.handleComponentSizeChange(ListControl.this);</span>
<span class="fc" id="L682">					}</span>
				});
<span class="fc" id="L684">			}</span>

			@Override
			public void treeCollapsed(TreeExpansionEvent event) {
<span class="fc" id="L688">				SwingUtilities.invokeLater(new Runnable() {</span>
					@Override
					public void run() {
<span class="fc" id="L691">						SwingRendererUtils.handleComponentSizeChange(ListControl.this);</span>
<span class="fc" id="L692">					}</span>
				});
<span class="fc" id="L694">			}</span>
		});
<span class="fc" id="L696">	}</span>

	protected JXTreeTable createTreeTable() {
<span class="fc" id="L699">		return new TreeTable();</span>
	}

	protected TableCellRenderer createTableCellRenderer() {
<span class="fc" id="L703">		return new ItemTableCellRenderer();</span>
	}

	protected TreeCellRenderer createTreeCellRenderer() {
<span class="fc" id="L707">		return new ItemTreeCellRenderer();</span>
	}

	protected ControlScrollPane createTreeTableScrollPane(Component view) {
<span class="fc" id="L711">		return new ControlScrollPane(view) {</span>
			private static final long serialVersionUID = 1L;

			@Override
			public Dimension getPreferredSize() {
<span class="fc" id="L716">				Dimension result = super.getPreferredSize();</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">				if (result == null) {</span>
<span class="nc" id="L718">					return null;</span>
				}
<span class="fc" id="L720">				IListStructuralInfo structure = getRootStructuralInfo();</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">				if (structure.getHeight() != -1) {</span>
<span class="fc" id="L722">					result.height = structure.getHeight();</span>
				}
<span class="fc" id="L724">				return result;</span>
			}

			@Override
			public Dimension getMinimumSize() {
<span class="nc" id="L729">				Dimension result = super.getMinimumSize();</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">				if (result != null) {</span>
<span class="nc" id="L731">					Dimension preferredSize = getPreferredSize();</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">					if (preferredSize != null) {</span>
<span class="nc" id="L733">						result.height = Math.min(result.height, preferredSize.height);</span>
					}
				}
<span class="nc" id="L736">				return result;</span>

			}

			@Override
			public Dimension getMaximumSize() {
<span class="nc" id="L742">				Dimension result = super.getMaximumSize();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">				if (result != null) {</span>
<span class="nc" id="L744">					Dimension preferredSize = getPreferredSize();</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">					if (preferredSize != null) {</span>
<span class="nc" id="L746">						result.height = Math.max(result.height, preferredSize.height);</span>
					}
				}
<span class="nc" id="L749">				return result;</span>
			}
		};
	}

	protected ControlScrollPane createTreeTableAndToolBarScrollPane(Component view) {
<span class="fc" id="L755">		return new ControlScrollPane(new ScrollPaneOptions(view, true, false)) {</span>
			private static final long serialVersionUID = 1L;
			{
<span class="fc" id="L758">				SwingRendererUtils.removeScrollPaneBorder(this);</span>
			}

			@Override
			public Dimension getPreferredSize() {
<span class="fc" id="L763">				Dimension result = super.getPreferredSize();</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">				if (result == null) {</span>
<span class="nc" id="L765">					return null;</span>
				}
<span class="fc" id="L767">				IListStructuralInfo structure = getRootStructuralInfo();</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">				if (structure.getHeight() != -1) {</span>
<span class="fc" id="L769">					result.height = structure.getHeight();</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">					if (getDetailsAccessMode() instanceof EmbeddedItemDetailsAccessMode) {</span>
<span class="fc" id="L771">						EmbeddedItemDetailsAccessMode embeddedItemDetailsAccessMode = (EmbeddedItemDetailsAccessMode) getDetailsAccessMode();</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">						if ((embeddedItemDetailsAccessMode</span>
<span class="fc" id="L773">								.getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.TOP)</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">								|| (embeddedItemDetailsAccessMode</span>
<span class="fc" id="L775">										.getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.BOTTOM)) {</span>
<span class="fc" id="L776">							result.height = Math.round(result.height / 2f);</span>
						}
					}
				}
<span class="fc" id="L780">				return result;</span>
			}

			@Override
			public Dimension getMinimumSize() {
<span class="fc" id="L785">				Dimension result = super.getMinimumSize();</span>
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">				if (result != null) {</span>
<span class="fc" id="L787">					Dimension preferredSize = getPreferredSize();</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">					if (preferredSize != null) {</span>
<span class="fc" id="L789">						result.height = Math.min(result.height, preferredSize.height);</span>
					}
				}
<span class="fc" id="L792">				return result;</span>

			}

			@Override
			public Dimension getMaximumSize() {
<span class="nc" id="L798">				Dimension result = super.getMaximumSize();</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">				if (result != null) {</span>
<span class="nc" id="L800">					Dimension preferredSize = getPreferredSize();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">					if (preferredSize != null) {</span>
<span class="nc" id="L802">						result.height = Math.max(result.height, preferredSize.height);</span>
					}
				}
<span class="nc" id="L805">				return result;</span>
			}

		};
	}

	protected ControlScrollPane createDetailsAreaScrollPane(Component view) {
<span class="fc" id="L812">		return new ControlScrollPane(view) {</span>
			private static final long serialVersionUID = 1L;
			{
<span class="fc" id="L815">				SwingRendererUtils.removeScrollPaneBorder(this);</span>
			}

			@Override
			public Dimension getPreferredSize() {
<span class="fc" id="L820">				Dimension result = super.getPreferredSize();</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">				if (result == null) {</span>
<span class="nc" id="L822">					return null;</span>
				}
<span class="fc" id="L824">				IListStructuralInfo structure = getRootStructuralInfo();</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">				if (structure.getHeight() != -1) {</span>
<span class="fc" id="L826">					result.height = structure.getHeight();</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">					if (getDetailsAccessMode() instanceof EmbeddedItemDetailsAccessMode) {</span>
<span class="fc" id="L828">						EmbeddedItemDetailsAccessMode embeddedItemDetailsAccessMode = (EmbeddedItemDetailsAccessMode) getDetailsAccessMode();</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">						if ((embeddedItemDetailsAccessMode</span>
<span class="fc" id="L830">								.getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.TOP)</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">								|| (embeddedItemDetailsAccessMode</span>
<span class="fc" id="L832">										.getEmbeddedDetailsAreaPosition() == ItemDetailsAreaPosition.BOTTOM)) {</span>
<span class="fc" id="L833">							result.height = Math.round(result.height / 2f);</span>
						}
					}
				}
<span class="fc" id="L837">				return result;</span>
			}

			@Override
			public Dimension getMinimumSize() {
<span class="fc" id="L842">				Dimension result = super.getMinimumSize();</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">				if (result != null) {</span>
<span class="fc" id="L844">					Dimension preferredSize = getPreferredSize();</span>
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">					if (preferredSize != null) {</span>
<span class="fc" id="L846">						result.height = Math.min(result.height, preferredSize.height);</span>
					}
				}
<span class="fc" id="L849">				return result;</span>

			}

			@Override
			public Dimension getMaximumSize() {
<span class="nc" id="L855">				Dimension result = super.getMaximumSize();</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">				if (result != null) {</span>
<span class="nc" id="L857">					Dimension preferredSize = getPreferredSize();</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">					if (preferredSize != null) {</span>
<span class="nc" id="L859">						result.height = Math.max(result.height, preferredSize.height);</span>
					}
				}
<span class="nc" id="L862">				return result;</span>
			}

		};
	}

	@Override
	public Dimension getPreferredSize() {
<span class="fc" id="L870">		Dimension result = super.getPreferredSize();</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L872">			return null;</span>
		}
<span class="fc" id="L874">		IListStructuralInfo structure = getRootStructuralInfo();</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">		if (structure.getWidth() != -1) {</span>
<span class="fc" id="L876">			result.width = structure.getWidth();</span>
		}
<span class="fc" id="L878">		return result;</span>
	}

	@Override
	public Dimension getMinimumSize() {
<span class="nc" id="L883">		Dimension result = super.getMinimumSize();</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L885">			Dimension preferredSize = getPreferredSize();</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">			if (preferredSize != null) {</span>
<span class="nc" id="L887">				result.width = Math.min(result.width, preferredSize.width);</span>
			}
		}
<span class="nc" id="L890">		return result;</span>

	}

	@Override
	public Dimension getMaximumSize() {
<span class="nc" id="L896">		Dimension result = super.getMaximumSize();</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L898">			Dimension preferredSize = getPreferredSize();</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">			if (preferredSize != null) {</span>
<span class="nc" id="L900">				result.width = Math.max(result.width, preferredSize.width);</span>
			}
		}
<span class="nc" id="L903">		return result;</span>
	}

	protected AbstractBufferedItemPositionFactory createItemPositionfactory() {
<span class="fc" id="L907">		return new BufferedItemPositionFactory(listData, this);</span>
	}

	protected TreeTableModel createTreeTableModel() {
<span class="fc" id="L911">		return new AbstractTreeTableModel(rootNode) {</span>

			@Override
			public int getIndexOfChild(Object parent, Object child) {
<span class="fc" id="L915">				return ((ItemNode) parent).getIndex((ItemNode) child);</span>
			}

			@Override
			public int getChildCount(Object parent) {
<span class="fc" id="L920">				return ((ItemNode) parent).getChildCount();</span>
			}

			@Override
			public Object getChild(Object parent, int index) {
<span class="fc" id="L925">				return ((ItemNode) parent).getChildAt(index);</span>
			}

			@Override
			public Object getValueAt(Object arg0, int fieldIndex) {
<span class="fc" id="L930">				return getCellValue((ItemNode) arg0, fieldIndex);</span>
			}

			@Override
			public int getColumnCount() {
<span class="fc" id="L935">				return ListControl.this.getColumnCount();</span>
			}

			@Override
			public String getColumnName(int column) {
<span class="fc" id="L940">				return swingRenderer.prepareMessageToDisplay(getColumnCaption(column));</span>
			}

		};
	}

	protected ItemNode createRootNode() {
<span class="fc" id="L947">		return new ItemNode(null);</span>
	}

	public List&lt;BufferedItemPosition&gt; getRootListItemPositions() {
<span class="fc" id="L951">		List&lt;ItemPosition&gt; result = itemPositionFactory.getRootItemPositions();</span>
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L953">			return null;</span>
		}
<span class="fc" id="L955">		return MiscUtils.&lt;ItemPosition, BufferedItemPosition&gt;convertCollectionUnsafely(result);</span>
	}

	public BufferedItemPosition getRootListItemPosition(int index) {
<span class="fc" id="L959">		return itemPositionFactory.getRootItemPosition(index);</span>
	}

	@Override
	public boolean showsCaption() {
<span class="fc" id="L964">		return true;</span>
	}

	protected void customizeCellRendererComponent(JLabel label, ItemNode node, int rowIndex, int columnIndex,
			boolean isSelected, boolean hasFocus) {
<span class="fc" id="L969">		label.putClientProperty(&quot;html.disable&quot;, Boolean.TRUE);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">		if (getItemPositionByNode(node) == null) {</span>
<span class="fc" id="L971">			return;</span>
		}
<span class="fc" id="L973">		String text = getCellValue(node, columnIndex);</span>
<span class="pc bpc" id="L974" title="1 of 4 branches missed.">		if ((text == null) || (text.length() == 0)) {</span>
<span class="fc" id="L975">			label.setText(&quot; &quot;);</span>
<span class="fc" id="L976">			label.setToolTipText(null);</span>
<span class="fc" id="L977">		} else {</span>
<span class="fc" id="L978">			label.setText(text.replaceAll(MiscUtils.getNewLineRegex(), &quot; &quot;));</span>
<span class="fc" id="L979">			label.setToolTipText(SwingRendererUtils.adaptToolTipTextToMultiline(text));</span>
		}

<span class="fc" id="L982">		Image iconImage = getCellIconImage(node, columnIndex);</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">		if (iconImage == null) {</span>
<span class="fc" id="L984">			label.setIcon(null);</span>
<span class="fc" id="L985">		} else {</span>
<span class="fc" id="L986">			label.setIcon(new ImageIcon(iconImage));</span>
		}

<span class="fc bfc" id="L989" title="All 2 branches covered.">		if (!isSelected) {</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">			if (listData.getEditorForegroundColor() != null) {</span>
<span class="fc" id="L991">				label.setForeground(SwingRendererUtils.getColor(listData.getEditorForegroundColor()));</span>
			}
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">			if (listData.getEditorBackgroundColor() != null) {</span>
<span class="fc" id="L994">				label.setBackground(SwingRendererUtils.getColor(listData.getEditorBackgroundColor()));</span>
			}
		}
<span class="fc" id="L997">	}</span>

	public String getColumnCaption(int columnIndex) {
<span class="fc" id="L1000">		IListStructuralInfo tableInfo = getRootStructuralInfo();</span>
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">		if (tableInfo == null) {</span>
<span class="nc" id="L1002">			return &quot;&quot;;</span>
		}
<span class="fc" id="L1004">		return tableInfo.getColumns().get(columnIndex).getCaption();</span>
	}

	public int getColumnCount() {
<span class="fc" id="L1008">		IListStructuralInfo tableInfo = getRootStructuralInfo();</span>
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">		if (tableInfo == null) {</span>
<span class="nc" id="L1010">			return 1;</span>
		}
<span class="fc" id="L1012">		return tableInfo.getColumns().size();</span>
	}

	protected String getCellValue(ItemNode node, int columnIndex) {
<span class="fc" id="L1016">		Map&lt;Integer, String&gt; nodeValues = valuesByNode.get(node);</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">		if (nodeValues == null) {</span>
<span class="fc" id="L1018">			nodeValues = new HashMap&lt;Integer, String&gt;();</span>
<span class="fc" id="L1019">			valuesByNode.put(node, nodeValues);</span>
		}
		String value;
<span class="fc bfc" id="L1022" title="All 2 branches covered.">		if (nodeValues.containsKey(columnIndex)) {</span>
<span class="fc" id="L1023">			value = nodeValues.get(columnIndex);</span>
<span class="fc" id="L1024">		} else {</span>
<span class="fc" id="L1025">			BufferedItemPosition itemPosition = getItemPositionByNode(node);</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">			if (itemPosition == null) {</span>
<span class="fc" id="L1027">				value = &quot;&quot;;</span>
<span class="fc" id="L1028">			} else {</span>
				try {
<span class="fc" id="L1030">					IListStructuralInfo tableInfo = getRootStructuralInfo();</span>
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">					if (tableInfo == null) {</span>
<span class="nc" id="L1032">						value = ReflectionUIUtils.toString(swingRenderer.getReflectionUI(), itemPosition.getItem());</span>
<span class="nc" id="L1033">					} else {</span>
<span class="fc" id="L1034">						List&lt;IColumnInfo&gt; columns = tableInfo.getColumns();</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">						if (columnIndex &lt; columns.size()) {</span>
<span class="fc" id="L1036">							IColumnInfo column = tableInfo.getColumns().get(columnIndex);</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">							if (column.hasCellValue(itemPosition)) {</span>
<span class="fc" id="L1038">								value = column.getCellValue(itemPosition);</span>
<span class="fc" id="L1039">							} else {</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">								if (columnIndex == 0) {</span>
<span class="nc" id="L1041">									value = ReflectionUIUtils.toString(swingRenderer.getReflectionUI(),</span>
<span class="nc" id="L1042">											itemPosition.getItem());</span>
<span class="nc" id="L1043">								} else {</span>
<span class="nc" id="L1044">									value = null;</span>
								}
							}
<span class="nc" id="L1047">						} else {</span>
<span class="nc" id="L1048">							value = null;</span>
						}
					}
<span class="nc" id="L1051">				} catch (Throwable t) {</span>
<span class="nc" id="L1052">					value = &quot;&lt;&quot; + MiscUtils.getPrettyErrorMessage(t) + &quot;&gt;&quot;;</span>
				}
			}
<span class="fc" id="L1055">			nodeValues.put(columnIndex, value);</span>
		}
<span class="fc" id="L1057">		return value;</span>
	}

	protected Image getCellIconImage(ItemNode node, int columnIndex) {
<span class="fc" id="L1061">		Image result = null;</span>
<span class="fc" id="L1062">		BufferedItemPosition itemPosition = getItemPositionByNode(node);</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">		if (columnIndex == 0) {</span>
<span class="fc" id="L1064">			result = swingRenderer.getObjectIconImage(itemPosition.getItem());</span>
<span class="fc" id="L1065">			Image overlayImage = getCellIconOverlayImage(node);</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">			if (overlayImage != null) {</span>
<span class="fc" id="L1067">				BufferedImage overlayedResult = new BufferedImage(</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">						(result != null) ? result.getWidth(null) : overlayImage.getWidth(null),</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">						(result != null) ? result.getHeight(null) : overlayImage.getHeight(null),</span>
<span class="fc" id="L1070">						BufferedImage.TYPE_INT_ARGB);</span>
<span class="fc" id="L1071">				Graphics2D g = overlayedResult.createGraphics();</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">				if (result != null) {</span>
<span class="fc" id="L1073">					g.drawImage(result, 0, 0, null);</span>
				}
<span class="fc bfc" id="L1075" title="All 2 branches covered.">				int drawY = (result != null) ? (result.getHeight(null) - overlayImage.getHeight(null)) : 0;</span>
<span class="fc" id="L1076">				g.drawImage(overlayImage, 0, drawY, null);</span>
<span class="fc" id="L1077">				g.dispose();</span>
<span class="fc" id="L1078">				result = overlayedResult;</span>
			}
		}
<span class="fc" id="L1081">		return result;</span>
	}

	protected Image getCellIconOverlayImage(ItemNode node) {
<span class="fc bfc" id="L1085" title="All 2 branches covered.">		if (listData.isControlValueValiditionEnabled()) {</span>
<span class="fc" id="L1086">			final BufferedItemPosition itemPosition = getItemPositionByNode(node);</span>
<span class="fc" id="L1087">			final boolean[] nodeValid = new boolean[] { true };</span>
<span class="fc" id="L1088">			final boolean[] subtreeValid = new boolean[] { true };</span>
<span class="fc" id="L1089">			visitItems(new IItemsVisitor() {</span>
				@Override
				public VisitStatus visitItem(BufferedItemPosition visitedItemPosition) {
<span class="fc" id="L1092">					if (!visitedItemPosition.getContainingListType()</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">							.isItemNodeValidityDetectionEnabled(visitedItemPosition)) {</span>
<span class="fc" id="L1094">						return VisitStatus.SUBTREE_VISIT_INTERRUPTED;</span>
					}
<span class="fc bfc" id="L1096" title="All 2 branches covered.">					if (getValidationError(visitedItemPosition) != null) {</span>
<span class="fc" id="L1097">						subtreeValid[0] = false;</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">						if (visitedItemPosition.equals(itemPosition)) {</span>
<span class="fc" id="L1099">							nodeValid[0] = false;</span>
						}
<span class="fc" id="L1101">						return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
					}
<span class="fc" id="L1103">					return VisitStatus.VISIT_NOT_INTERRUPTED;</span>
				}
<span class="fc" id="L1105">			}, node);</span>
<span class="fc bfc" id="L1106" title="All 2 branches covered.">			if (!nodeValid[0]) {</span>
<span class="fc" id="L1107">				return SwingRendererUtils.ERROR_OVERLAY_ICON.getImage();</span>
			}
<span class="fc bfc" id="L1109" title="All 2 branches covered.">			if (!subtreeValid[0]) {</span>
<span class="fc" id="L1110">				return SwingRendererUtils.WEAK_ERROR_OVERLAY_ICON.getImage();</span>
			}
		}
<span class="fc" id="L1113">		return null;</span>
	}

	public Exception getValidationError(BufferedItemPosition itemPosition) {
<span class="fc" id="L1117">		return swingRenderer.getReflectionUI().getValidationErrorRegistry().getValidationError(itemPosition.getItem(),</span>
<span class="fc" id="L1118">				null);</span>
	}

	protected List&lt;AbstractAction&gt; getCurrentSelectionActions() {

<span class="fc" id="L1123">		List&lt;AbstractAction&gt; result = new ArrayList&lt;AbstractAction&gt;();</span>

		AbstractStandardListAction standardAction;

<span class="fc" id="L1127">		standardAction = createOpenItemAction();</span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1129">			result.add(standardAction);</span>
		}

<span class="fc" id="L1132">		result.add(SEPARATOR_ACTION);</span>

<span class="fc" id="L1134">		standardAction = createAddChildAction();</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">		if (standardAction.isValid()) {</span>
<span class="fc" id="L1136">			result.add(standardAction);</span>
		}

<span class="fc" id="L1139">		standardAction = createInsertAction(InsertPosition.BEFORE);</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">		if (standardAction.isValid()) {</span>
<span class="fc" id="L1141">			result.add(standardAction);</span>
		}

<span class="fc" id="L1144">		standardAction = createInsertAction(InsertPosition.AFTER);</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">		if (standardAction.isValid()) {</span>
<span class="fc" id="L1146">			result.add(standardAction);</span>
		}

<span class="fc" id="L1149">		standardAction = createInsertAction(InsertPosition.UNKNOWN);</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1151">			result.add(standardAction);</span>
		}

<span class="fc" id="L1154">		result.add(SEPARATOR_ACTION);</span>

<span class="fc" id="L1156">		standardAction = createCopyAction();</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">		if (standardAction.isValid()) {</span>
<span class="fc" id="L1158">			result.add(standardAction);</span>
		}

<span class="fc" id="L1161">		standardAction = createCutAction();</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">		if (standardAction.isValid()) {</span>
<span class="fc" id="L1163">			result.add(standardAction);</span>
		}

<span class="fc" id="L1166">		standardAction = createPasteAction(InsertPosition.BEFORE);</span>
<span class="pc bpc" id="L1167" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1168">			result.add(standardAction);</span>
		}

<span class="fc" id="L1171">		standardAction = createPasteAction(InsertPosition.AFTER);</span>
<span class="pc bpc" id="L1172" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1173">			result.add(standardAction);</span>
		}

<span class="fc" id="L1176">		standardAction = createPasteAction(InsertPosition.UNKNOWN);</span>
<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1178">			result.add(standardAction);</span>
		}

<span class="fc" id="L1181">		standardAction = createPasteIntoAction();</span>
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1183">			result.add(standardAction);</span>
		}

<span class="fc" id="L1186">		result.add(SEPARATOR_ACTION);</span>

<span class="fc" id="L1188">		standardAction = createMoveAction(-1);</span>
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1190">			result.add(standardAction);</span>
		}

<span class="fc" id="L1193">		standardAction = createMoveAction(1);</span>
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">		if (standardAction.isValid()) {</span>
<span class="nc" id="L1195">			result.add(standardAction);</span>
		}

<span class="fc" id="L1198">		result.add(SEPARATOR_ACTION);</span>

<span class="fc" id="L1200">		standardAction = createRemoveAction();</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">		if (standardAction.isValid()) {</span>
<span class="fc" id="L1202">			result.add(standardAction);</span>
		}

<span class="fc" id="L1205">		standardAction = createClearAction();</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">		if (standardAction.isValid()) {</span>
<span class="fc" id="L1207">			result.add(standardAction);</span>
		}

<span class="fc" id="L1210">		result.add(SEPARATOR_ACTION);</span>

<span class="fc" id="L1212">		List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="fc" id="L1213">		result.addAll(getDynamicPropertyHooks(selection));</span>
<span class="fc" id="L1214">		result.addAll(getDynamicActionHooks(selection));</span>

<span class="fc" id="L1216">		result = removeSeparatorsInExcess(result);</span>
<span class="fc" id="L1217">		return result;</span>
	}

	public List&lt;AbstractAction&gt; getDynamicActionHooks(List&lt;BufferedItemPosition&gt; selection) {
<span class="fc" id="L1221">		List&lt;AbstractAction&gt; result = new ArrayList&lt;AbstractAction&gt;();</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">		for (IDynamicListAction listAction : getRootListType().getDynamicActions(selection,</span>
<span class="fc" id="L1223">				getModificationFactoryAccessor())) {</span>
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">			if ((listAction.getDisplayMode() == DisplayMode.CONTEXT_MENU)</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">					|| (listAction.getDisplayMode() == DisplayMode.TOOLBAR_AND_CONTEXT_MENU)) {</span>
<span class="fc" id="L1226">				result.add(createDynamicActionHook(listAction));</span>
			}
		}
<span class="fc" id="L1229">		return result;</span>
	}

	public List&lt;AbstractAction&gt; getDynamicPropertyHooks(List&lt;BufferedItemPosition&gt; selection) {
<span class="fc" id="L1233">		List&lt;AbstractAction&gt; result = new ArrayList&lt;AbstractAction&gt;();</span>
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">		for (IDynamicListProperty listProperty : getRootListType().getDynamicProperties(selection,</span>
<span class="fc" id="L1235">				getModificationFactoryAccessor())) {</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">			if ((listProperty.getDisplayMode() == DisplayMode.CONTEXT_MENU)</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">					|| (listProperty.getDisplayMode() == DisplayMode.TOOLBAR_AND_CONTEXT_MENU)) {</span>
<span class="nc" id="L1238">				result.add(createDynamicPropertyHook(listProperty));</span>
			}
		}
<span class="fc" id="L1241">		return result;</span>
	}

	protected Mapper&lt;ItemPosition, ListModificationFactory&gt; getModificationFactoryAccessor() {
<span class="fc" id="L1245">		return new Mapper&lt;ItemPosition, ListModificationFactory&gt;() {</span>
			@Override
			public ListModificationFactory get(ItemPosition itemPosition) {
<span class="fc" id="L1248">				return createListModificationFactory((BufferedItemPosition) itemPosition);</span>
			}
		};
	}

	protected List&lt;AbstractAction&gt; removeSeparatorsInExcess(List&lt;AbstractAction&gt; actions) {
<span class="fc" id="L1254">		List&lt;AbstractAction&gt; result = new ArrayList&lt;AbstractAction&gt;();</span>
<span class="fc" id="L1255">		AbstractAction lastAction = null;</span>
<span class="fc bfc" id="L1256" title="All 2 branches covered.">		for (AbstractAction action : actions) {</span>
<span class="fc bfc" id="L1257" title="All 2 branches covered.">			if (action == SEPARATOR_ACTION) {</span>
<span class="fc bfc" id="L1258" title="All 2 branches covered.">				if (lastAction == SEPARATOR_ACTION) {</span>
<span class="fc" id="L1259">					continue;</span>
				}
			}
<span class="fc" id="L1262">			result.add(action);</span>
<span class="fc" id="L1263">			lastAction = action;</span>
		}
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">		if (result.size() &gt; 0) {</span>
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">			if (SEPARATOR_ACTION == result.get(0)) {</span>
<span class="fc" id="L1267">				result.remove(0);</span>
			}
		}
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">		if (result.size() &gt; 0) {</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">			if (SEPARATOR_ACTION == result.get(result.size() - 1)) {</span>
<span class="fc" id="L1272">				result.remove(result.size() - 1);</span>
			}
		}
<span class="fc" id="L1275">		return result;</span>
	}

	protected boolean canCopyAll(List&lt;BufferedItemPosition&gt; selection) {
<span class="fc" id="L1279">		boolean result = true;</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">		for (BufferedItemPosition selectionItem : selection) {</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">			if (!ReflectionUIUtils.canCopy(swingRenderer.getReflectionUI(), selectionItem.getItem())) {</span>
<span class="fc" id="L1282">				result = false;</span>
<span class="fc" id="L1283">				break;</span>
			}
		}
<span class="fc" id="L1286">		return result;</span>
	}

	protected boolean canRemoveAll(List&lt;BufferedItemPosition&gt; selection) {
<span class="fc" id="L1290">		boolean result = true;</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">		for (BufferedItemPosition selectionItem : selection) {</span>
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">			if (!createListModificationFactory(selectionItem).canRemove(selectionItem.getIndex())) {</span>
<span class="nc" id="L1293">				result = false;</span>
<span class="nc" id="L1294">				break;</span>
			}
		}
<span class="fc" id="L1297">		return result;</span>
	}

	protected boolean canMoveAll(List&lt;BufferedItemPosition&gt; selection, int offset) {
<span class="fc" id="L1301">		boolean result = true;</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">		for (BufferedItemPosition selectionItem : selection) {</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">			if (!createListModificationFactory(selectionItem).canMove(selectionItem.getIndex(), offset)) {</span>
<span class="fc" id="L1304">				result = false;</span>
<span class="fc" id="L1305">				break;</span>
			}
		}
<span class="fc" id="L1308">		return result;</span>
	}

	protected ListModificationFactory createListModificationFactory(BufferedItemPosition anyListItemPosition) {
<span class="fc" id="L1312">		return new ListModificationFactory(anyListItemPosition);</span>
	}

	protected boolean allSelectionItemsInSameList() {
<span class="fc" id="L1316">		boolean result = true;</span>
<span class="fc" id="L1317">		List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="fc" id="L1318">		BufferedItemPosition firstSelectionItem = selection.get(0);</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">		for (BufferedItemPosition selectionItem : selection) {</span>
<span class="fc" id="L1320">			if (!MiscUtils.equalsOrBothNull(firstSelectionItem.getParentItemPosition(),</span>
<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">					selectionItem.getParentItemPosition())) {</span>
<span class="nc" id="L1322">				result = false;</span>
<span class="nc" id="L1323">				break;</span>
			}
		}
<span class="fc" id="L1326">		return result;</span>
	}

	protected AbstractStandardListAction createClearAction() {
<span class="fc" id="L1330">		return new ClearAction();</span>
	}

	protected boolean userConfirms(String question) {
<span class="fc" id="L1334">		return swingRenderer.openQuestionDialog(SwingUtilities.getWindowAncestor(ListControl.this), question, null,</span>
<span class="fc" id="L1335">				&quot;OK&quot;, &quot;Cancel&quot;);</span>
	}

	protected AbstractStandardListAction createMoveAction(final int offset) {
<span class="fc" id="L1339">		return new MoveAction(offset);</span>

	}

	public BufferedItemPosition getSingleSelection() {
<span class="fc" id="L1344">		List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="pc bpc" id="L1345" title="1 of 4 branches missed.">		if ((selection.size() == 0) || (selection.size() &gt; 1)) {</span>
<span class="fc" id="L1346">			return null;</span>
		} else {
<span class="fc" id="L1348">			return selection.get(0);</span>
		}
	}

	public List&lt;BufferedItemPosition&gt; getSelection() {
<span class="fc" id="L1353">		List&lt;BufferedItemPosition&gt; result = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="fc bfc" id="L1354" title="All 2 branches covered.">		for (int selectedRow : treeTableComponent.getSelectedRows()) {</span>
<span class="fc" id="L1355">			TreePath path = treeTableComponent.getPathForRow(selectedRow);</span>
<span class="pc bpc" id="L1356" title="1 of 2 branches missed.">			if (path == null) {</span>
<span class="nc" id="L1357">				continue;</span>
			}
<span class="fc" id="L1359">			ItemNode selectedNode = (ItemNode) path.getLastPathComponent();</span>
<span class="fc" id="L1360">			BufferedItemPosition bufferedItemPosition = getItemPositionByNode(selectedNode);</span>
<span class="fc" id="L1361">			result.add(bufferedItemPosition);</span>
		}
<span class="fc" id="L1363">		return result;</span>
	}

	public void setSingleSelection(BufferedItemPosition toSelect) {
<span class="fc bfc" id="L1367" title="All 2 branches covered.">		if (toSelect == null) {</span>
<span class="fc" id="L1368">			setSelection(Collections.emptyList());</span>
<span class="fc" id="L1369">		} else {</span>
<span class="fc" id="L1370">			setSelection(Collections.singletonList(toSelect));</span>
		}
<span class="fc" id="L1372">	}</span>

	public BufferedItemPosition findItemPositionByReference(final Object item) {
<span class="fc" id="L1375">		final BufferedItemPosition[] result = new BufferedItemPosition[1];</span>
<span class="fc" id="L1376">		visitItemsInBreadthFirstSearchMode(new IItemsVisitor() {</span>
			@Override
			public VisitStatus visitItem(BufferedItemPosition itemPosition) {
<span class="fc bfc" id="L1379" title="All 2 branches covered.">				if (itemPosition.getItem() == item) {</span>
<span class="fc" id="L1380">					result[0] = itemPosition;</span>
<span class="fc" id="L1381">					return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
				}
<span class="fc" id="L1383">				return VisitStatus.VISIT_NOT_INTERRUPTED;</span>
			}
		});
<span class="fc" id="L1386">		return result[0];</span>
	}

	public List&lt;BufferedItemPosition&gt; findItemPositionsByValue(Object item) {
<span class="nc" id="L1390">		final List&lt;BufferedItemPosition&gt; result = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="nc" id="L1391">		visitItemsInBreadthFirstSearchMode(new IItemsVisitor() {</span>
			@Override
			public VisitStatus visitItem(BufferedItemPosition itemPosition) {
<span class="nc bnc" id="L1394" title="All 2 branches missed.">				if (itemPosition.getItem().equals(item)) {</span>
<span class="nc" id="L1395">					result.add(itemPosition);</span>
				}
<span class="nc" id="L1397">				return VisitStatus.VISIT_NOT_INTERRUPTED;</span>
			}
		});
<span class="nc" id="L1400">		return result;</span>
	}

	public BufferedItemPosition findFirstItemPositionByValue(Object item) {
<span class="nc" id="L1404">		List&lt;BufferedItemPosition&gt; itemPositions = findItemPositionsByValue(item);</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">		if (itemPositions.size() == 0) {</span>
<span class="nc" id="L1406">			return null;</span>
		}
<span class="nc" id="L1408">		return itemPositions.get(0);</span>
	}

	protected BufferedItemPosition getItemPositionByNode(ItemNode node) {
<span class="fc" id="L1412">		Object userObject = node.getUserObject();</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">		if (!(userObject instanceof BufferedItemPosition)) {</span>
<span class="fc" id="L1414">			return null;</span>
		}
<span class="fc" id="L1416">		return (BufferedItemPosition) userObject;</span>
	}

	public void setSelection(List&lt;BufferedItemPosition&gt; toSelect) {
<span class="fc bfc" id="L1420" title="All 2 branches covered.">		if (Arrays.equals(getSelection().toArray(), toSelect.toArray())) {</span>
<span class="fc" id="L1421">			return;</span>
		}
<span class="fc" id="L1423">		List&lt;TreePath&gt; treePaths = new ArrayList&lt;TreePath&gt;();</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">		for (int i = 0; i &lt; toSelect.size(); i++) {</span>
<span class="fc" id="L1425">			BufferedItemPosition itemPosition = toSelect.get(i);</span>
<span class="fc" id="L1426">			ItemNode itemNode = findNode(itemPosition);</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">			if (itemNode == null) {</span>
<span class="nc" id="L1428">				BufferedItemPosition parentItemPosition = itemPosition.getParentItemPosition();</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">				if (parentItemPosition == null) {</span>
<span class="nc" id="L1430">					treeTableComponent.clearSelection();</span>
<span class="nc" id="L1431">					return;</span>
				}
<span class="nc" id="L1433">				toSelect = new ArrayList&lt;BufferedItemPosition&gt;(toSelect);</span>
<span class="nc" id="L1434">				toSelect.set(i, parentItemPosition);</span>
<span class="nc" id="L1435">				setSelection(toSelect);</span>
<span class="nc" id="L1436">				return;</span>
			}
<span class="fc" id="L1438">			treePaths.add(new TreePath(itemNode.getPath()));</span>
		}
<span class="fc" id="L1440">		treeTableComponent.getTreeSelectionModel().setSelectionPaths(treePaths.toArray(new TreePath[treePaths.size()]));</span>
<span class="fc" id="L1441">	}</span>

	public void scrollTo(BufferedItemPosition itemPosition) {
<span class="fc" id="L1444">		ItemNode itemNode = findNode(itemPosition);</span>
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">		if (itemNode == null) {</span>
<span class="nc" id="L1446">			return;</span>
		}
<span class="fc" id="L1448">		TreePath treePath = new TreePath(itemNode.getPath());</span>
		try {
<span class="fc" id="L1450">			treeTableComponent.scrollRowToVisible(treeTableComponent.getRowForPath(treePath));</span>
<span class="pc" id="L1451">		} catch (Throwable ignore) {</span>
		}
<span class="fc" id="L1453">	}</span>

	public boolean isItemPositionExpanded(BufferedItemPosition itemPosition) {
<span class="fc" id="L1456">		ItemNode node = findNode(itemPosition);</span>
<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">		if (node == null) {</span>
<span class="nc" id="L1458">			return false;</span>
		}
<span class="fc" id="L1460">		TreePath treePath = new TreePath(node.getPath());</span>
<span class="fc" id="L1461">		return treeTableComponent.isExpanded(treePath);</span>
	}

	public void expandItemPosition(BufferedItemPosition itemPosition) {
<span class="fc" id="L1465">		ItemNode node = findNode(itemPosition);</span>
<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">		if (node == null) {</span>
<span class="nc" id="L1467">			return;</span>
		}
<span class="fc" id="L1469">		TreePath treePath = new TreePath(node.getPath());</span>
<span class="fc" id="L1470">		treeTableComponent.expandPath(treePath);</span>
<span class="fc" id="L1471">	}</span>

	public void collapseItemPosition(BufferedItemPosition itemPosition) {
<span class="nc" id="L1474">		ItemNode node = findNode(itemPosition);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">		if (node == null) {</span>
<span class="nc" id="L1476">			return;</span>
		}
<span class="nc" id="L1478">		TreePath treePath = new TreePath(node.getPath());</span>
<span class="nc" id="L1479">		treeTableComponent.collapsePath(treePath);</span>
<span class="nc" id="L1480">	}</span>

	public void expandItemPositions(int maximumDepth) {
<span class="fc" id="L1483">		visitItemsInBreadthFirstSearchMode(new IItemsVisitor() {</span>
			@Override
			public VisitStatus visitItem(BufferedItemPosition itemPosition) {
<span class="fc bfc" id="L1486" title="All 2 branches covered.">				if (itemPosition.getDepth() &gt;= maximumDepth) {</span>
<span class="fc" id="L1487">					return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
				}
<span class="fc" id="L1489">				expandItemPosition(itemPosition);</span>
<span class="fc" id="L1490">				return VisitStatus.VISIT_NOT_INTERRUPTED;</span>
			}
		});
<span class="fc" id="L1493">	}</span>

	public void expandAllItemPositions() {
<span class="nc" id="L1496">		treeTableComponent.expandAll();</span>
<span class="nc" id="L1497">	}</span>

	public void collapseAllItemPositions() {
<span class="fc" id="L1500">		treeTableComponent.collapseAll();</span>
<span class="fc" id="L1501">	}</span>

	public List&lt;BufferedItemPosition&gt; getExpandedItemPositions(BufferedItemPosition parentItemPosition) {
<span class="fc" id="L1504">		List&lt;BufferedItemPosition&gt; result = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">		ItemNode parentNode = (parentItemPosition != null) ? findNode(parentItemPosition) : rootNode;</span>
<span class="fc" id="L1506">		Enumeration&lt;?&gt; expandedPaths = treeTableComponent.getExpandedDescendants(new TreePath(parentNode));</span>
<span class="fc bfc" id="L1507" title="All 2 branches covered.">		if (expandedPaths != null) {</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">			while (expandedPaths.hasMoreElements()) {</span>
<span class="fc" id="L1509">				TreePath treePath = (TreePath) expandedPaths.nextElement();</span>
<span class="fc" id="L1510">				ItemNode node = (ItemNode) treePath.getLastPathComponent();</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">				if (node == rootNode) {</span>
<span class="fc" id="L1512">					continue;</span>
				}
<span class="fc" id="L1514">				BufferedItemPosition itemPosition = getItemPositionByNode(node);</span>
<span class="fc" id="L1515">				result.add(itemPosition);</span>
			}
		}
<span class="fc" id="L1518">		return result;</span>
	}

	protected ItemNode findNode(BufferedItemPosition itemPosition) {
		ItemNode parentNode;
<span class="fc bfc" id="L1523" title="All 2 branches covered.">		if (itemPosition.isRoot()) {</span>
<span class="fc" id="L1524">			parentNode = rootNode;</span>
<span class="fc" id="L1525">		} else {</span>
<span class="fc" id="L1526">			parentNode = findNode(itemPosition.getParentItemPosition());</span>
		}
<span class="pc bpc" id="L1528" title="1 of 2 branches missed.">		if (parentNode == null) {</span>
<span class="nc" id="L1529">			return null;</span>
		}
<span class="pc bpc" id="L1531" title="1 of 2 branches missed.">		if (itemPosition.getIndex() &lt; 0) {</span>
<span class="nc" id="L1532">			return null;</span>
		}
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">		if (itemPosition.getIndex() &gt;= parentNode.getChildCount()) {</span>
<span class="nc" id="L1535">			return null;</span>
		}
<span class="fc" id="L1537">		ItemNode result = (ItemNode) parentNode.getChildAt(itemPosition.getIndex());</span>
<span class="fc" id="L1538">		return result;</span>
	}

	protected AbstractStandardListAction createRemoveAction() {
<span class="fc" id="L1542">		return new RemoveAction();</span>
	}

	protected void purgePositionsAfterItemRemoval(List&lt;BufferedItemPosition&gt; toUpdate, BufferedItemPosition removed) {
<span class="nc bnc" id="L1546" title="All 2 branches missed.">		for (int i = 0; i &lt; toUpdate.size(); i++) {</span>
<span class="nc" id="L1547">			BufferedItemPosition itemPosition = toUpdate.get(i);</span>
<span class="nc bnc" id="L1548" title="All 4 branches missed.">			if (itemPosition.equals(removed) || itemPosition.getAncestors().contains(removed)) {</span>
<span class="nc" id="L1549">				toUpdate.remove(i);</span>
<span class="nc" id="L1550">				i--;</span>
			}
		}
<span class="nc" id="L1553">	}</span>

	protected void shiftPositionsAfterItemRemoval(List&lt;BufferedItemPosition&gt; toUpdate, BufferedItemPosition removed) {
<span class="nc bnc" id="L1556" title="All 2 branches missed.">		for (int i = 0; i &lt; toUpdate.size(); i++) {</span>
<span class="nc" id="L1557">			BufferedItemPosition itemPosition = toUpdate.get(i);</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">			if (itemPosition.getPreviousSiblings().contains(removed)) {</span>
<span class="nc" id="L1559">				toUpdate.set(i, itemPosition.getSibling(itemPosition.getIndex() - 1));</span>
			}
		}
<span class="nc" id="L1562">	}</span>

	protected AbstractStandardListAction createInsertAction(final InsertPosition insertPosition) {
<span class="fc" id="L1565">		return new InsertAction(insertPosition);</span>
	}

	protected ItemUIBuilder openAnticipatedItemDialog(BufferedItemPosition anticipatedItemPosition,
			Object anticipatedItem) {
<span class="fc" id="L1570">		ItemUIBuilder dialogBuilder = createAnticipatedItemDialogBuilder(anticipatedItemPosition, anticipatedItem);</span>
<span class="fc" id="L1571">		dialogBuilder.createAndShowDialog();</span>
<span class="fc" id="L1572">		return dialogBuilder;</span>
	}

	protected Object onItemCreationRequest(BufferedItemPosition itemPosition, boolean provideCreationOptions) {
<span class="fc" id="L1576">		IListTypeInfo listType = itemPosition.getContainingListType();</span>
<span class="fc" id="L1577">		ITypeInfo typeToInstantiate = listType.getItemType();</span>
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">		if (typeToInstantiate == null) {</span>
<span class="nc" id="L1579">			typeToInstantiate = swingRenderer.getReflectionUI().getTypeInfo(new JavaTypeInfoSource(Object.class, null));</span>
		}

<span class="fc" id="L1582">		BufferedItemPosition parentItemPosition = itemPosition.getParentItemPosition();</span>
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">		if (parentItemPosition != null) {</span>
<span class="nc" id="L1584">			Object parentItem = parentItemPosition.getItem();</span>
<span class="nc" id="L1585">			IFieldInfo containingListField = itemPosition.getContainingListFieldIfNotRoot();</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">			if (containingListField.getAlternativeListItemConstructors(parentItem) != null) {</span>
<span class="nc" id="L1587">				typeToInstantiate = new FieldAlternativeListItemConstructorsInstaller(swingRenderer.getReflectionUI(),</span>
<span class="nc" id="L1588">						parentItem, containingListField).wrapTypeInfo(typeToInstantiate);</span>
			}
		}

<span class="fc bfc" id="L1592" title="All 2 branches covered.">		if (provideCreationOptions) {</span>
<span class="fc" id="L1593">			return swingRenderer.onTypeInstantiationRequest(ListControl.this, typeToInstantiate);</span>
		} else {
<span class="fc" id="L1595">			return ReflectionUIUtils.createDefaultInstance(typeToInstantiate);</span>
		}
	}

	protected boolean wouldDialogBeDisplayedOnItemCreation(BufferedItemPosition newItemPosition) {
<span class="fc" id="L1600">		IListTypeInfo listType = newItemPosition.getContainingListType();</span>
<span class="fc" id="L1601">		ItemCreationMode itemCreationMode = listType.getItemCreationMode();</span>
<span class="fc bfc" id="L1602" title="All 2 branches covered.">		if (itemCreationMode == ItemCreationMode.UNDEFINED) {</span>
<span class="fc" id="L1603">			itemCreationMode = getRelevantItemCreationMode(newItemPosition);</span>
		}
<span class="fc bfc" id="L1605" title="All 2 branches covered.">		if ((itemCreationMode == ItemCreationMode.CUSTOM_UNVERIFIED_INSTANCE)</span>
<span class="fc bfc" id="L1606" title="All 2 branches covered.">				|| (itemCreationMode == ItemCreationMode.CUSTOM_VERIFIED_INSTANCE)) {</span>
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">			if (listType.isItemNullValueSupported()) {</span>
<span class="nc" id="L1608">				return true;</span>
			}
<span class="fc" id="L1610">			ITypeInfo typeToInstantiate = listType.getItemType();</span>
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">			if (typeToInstantiate == null) {</span>
<span class="nc" id="L1612">				typeToInstantiate = swingRenderer.getReflectionUI()</span>
<span class="nc" id="L1613">						.getTypeInfo(new JavaTypeInfoSource(Object.class, null));</span>
			}
<span class="pc bpc" id="L1615" title="1 of 2 branches missed.">			if (swingRenderer.isDecisionRequiredOnTypeInstantiationRequest(typeToInstantiate)) {</span>
<span class="fc" id="L1616">				return true;</span>
			}
		}
<span class="pc bpc" id="L1619" title="1 of 2 branches missed.">		if ((itemCreationMode == ItemCreationMode.VERIFIED_NULL)</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">				|| (itemCreationMode == ItemCreationMode.DEFAULT_VERIFIED_INSTANCE)</span>
<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">				|| (itemCreationMode == ItemCreationMode.CUSTOM_VERIFIED_INSTANCE)) {</span>
<span class="fc" id="L1622">			return true;</span>
		}
<span class="fc" id="L1624">		return false;</span>
	};

	protected ItemCreationMode getRelevantItemCreationMode(BufferedItemPosition newItemPosition) {
<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">		if ((newItemPosition.getContainingListType().getItemType() != null) &amp;&amp; ReflectionUIUtils</span>
<span class="fc bfc" id="L1629" title="All 2 branches covered.">				.canCreateDefaultInstance(newItemPosition.getContainingListType().getItemType(), false)) {</span>
<span class="pc bpc" id="L1630" title="1 of 4 branches missed.">			if (getDetailsAccessMode().hasDetachedDetailsDisplayOption() &amp;&amp; (getMasterListControl() == null)) {</span>
<span class="fc" id="L1631">				return ItemCreationMode.DEFAULT_VERIFIED_INSTANCE;</span>
			} else {
<span class="fc" id="L1633">				return ItemCreationMode.DEFAULT_UNVERIFIED_INSTANCE;</span>
			}
		} else {
<span class="fc bfc" id="L1636" title="All 4 branches covered.">			if (getDetailsAccessMode().hasDetachedDetailsDisplayOption() &amp;&amp; (getMasterListControl() == null)) {</span>
<span class="fc" id="L1637">				return ItemCreationMode.CUSTOM_VERIFIED_INSTANCE;</span>
			} else {
<span class="fc" id="L1639">				return ItemCreationMode.CUSTOM_UNVERIFIED_INSTANCE;</span>
			}
		}
	}

	protected AbstractStandardListAction createAddChildAction() {
<span class="fc" id="L1645">		return new AddChildAction();</span>
	};

	protected String getItemTitle(BufferedItemPosition itemPosition) {
<span class="fc" id="L1649">		BufferedItemPosition fakeItemPosition = itemPosition.getSibling(-1);</span>
<span class="fc" id="L1650">		fakeItemPosition = (BufferedItemPosition) fakeItemPosition.clone();</span>
<span class="fc" id="L1651">		fakeItemPosition.setFakeItem(null);</span>
<span class="fc" id="L1652">		Object capsule = createItemUIBuilder(fakeItemPosition).getNewCapsule();</span>
<span class="fc" id="L1653">		ITypeInfo encapsulatedObjectType = swingRenderer.getReflectionUI()</span>
<span class="fc" id="L1654">				.getTypeInfo(swingRenderer.getReflectionUI().getTypeInfoSource(capsule));</span>
<span class="fc" id="L1655">		return encapsulatedObjectType.getCaption();</span>
	}

	protected ItemUIBuilder createItemUIBuilder(BufferedItemPosition bufferedItemPosition) {
<span class="fc" id="L1659">		return new ItemUIBuilder(bufferedItemPosition);</span>
	}

	protected AnticipatedItemDialogBuilder createAnticipatedItemDialogBuilder(BufferedItemPosition bufferedItemPosition,
			Object item) {
<span class="fc" id="L1664">		return new AnticipatedItemDialogBuilder(bufferedItemPosition, item);</span>
	}

	protected AbstractStandardListAction createCopyAction() {
<span class="fc" id="L1668">		return new CopyAction();</span>
	}

	protected AbstractStandardListAction createCutAction() {
<span class="fc" id="L1672">		return new CutAction();</span>
	}

	protected BufferedItemPosition getPositionSelectedByItemRemoval(BufferedItemPosition itemPosition) {
<span class="nc bnc" id="L1676" title="All 2 branches missed.">		if (itemPosition.getIndex() &gt; 0) {</span>
<span class="nc" id="L1677">			return itemPosition.getSibling(itemPosition.getIndex() - 1);</span>
		} else {
<span class="nc" id="L1679">			return itemPosition.getParentItemPosition();</span>
		}
	}

	protected AbstractStandardListAction createPasteAction(final InsertPosition insertPosition) {
<span class="fc" id="L1684">		return new PasteAction(insertPosition);</span>
	}

	protected AbstractStandardListAction createPasteIntoAction() {
<span class="fc" id="L1688">		return new PasteIntoAction();</span>
	}

	public ITypeInfo getRootListItemType() {
<span class="nc" id="L1692">		return getRootListType().getItemType();</span>
	}

	public IListTypeInfo getRootListType() {
<span class="fc" id="L1696">		return (IListTypeInfo) listData.getType();</span>
	}

	protected AbstractStandardListAction createDynamicPropertyHook(final IDynamicListProperty dynamicProperty) {
<span class="fc" id="L1700">		return new DynamicPropertyHook(dynamicProperty);</span>
	}

	protected AbstractStandardListAction createDynamicActionHook(final IDynamicListAction dynamicAction) {
<span class="fc" id="L1704">		return new DynamicActionHook(dynamicAction);</span>
	}

	protected AbstractStandardListAction createOpenItemAction() {
<span class="fc" id="L1708">		return new OpenItemAction();</span>
	}

	protected String getItemModificationTitle() {
<span class="fc bfc" id="L1712" title="All 2 branches covered.">		if (getRootListTitle().length() == 0) {</span>
<span class="fc" id="L1713">			return null;</span>
		}
<span class="fc" id="L1715">		return &quot;Edit '&quot; + getRootListTitle() + &quot;' item&quot;;</span>
	}

	public void addListControlSelectionListener(Listener&lt;List&lt;BufferedItemPosition&gt;&gt; listener) {
<span class="fc" id="L1719">		selectionListeners.add(listener);</span>
<span class="fc" id="L1720">	}</span>

	public void removeListControlSelectionListener(Listener&lt;List&lt;BufferedItemPosition&gt;&gt; listener) {
<span class="nc" id="L1723">		selectionListeners.remove(listener);</span>
<span class="nc" id="L1724">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	public Listener&lt;List&lt;BufferedItemPosition&gt;&gt;[] getListControlSelectionListeners() {
<span class="nc" id="L1728">		return selectionListeners.toArray(new Listener[selectionListeners.size()]);</span>
	}

	protected void initializeSelectionListening() {
<span class="fc" id="L1732">		treeTableComponent.addTreeSelectionListener(new TreeSelectionListener() {</span>
			@Override
			public void valueChanged(TreeSelectionEvent e) {
				try {
<span class="fc" id="L1736">					fireSelectionEvent();</span>
<span class="pc" id="L1737">				} catch (Throwable t) {</span>
<span class="nc" id="L1738">					swingRenderer.handleException(ListControl.this, t);</span>
				}
<span class="fc" id="L1740">			}</span>
		});
<span class="fc" id="L1742">	}</span>

	protected void fireSelectionEvent() {
<span class="fc bfc" id="L1745" title="All 2 branches covered.">		if (!selectionListenersEnabled) {</span>
<span class="fc" id="L1746">			return;</span>
		}
<span class="fc" id="L1748">		List&lt;BufferedItemPosition&gt; newSelection = getSelection();</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">		for (Listener&lt;List&lt;BufferedItemPosition&gt;&gt; listener : selectionListeners) {</span>
			try {
<span class="fc" id="L1751">				listener.handle(newSelection);</span>
<span class="pc" id="L1752">			} catch (Throwable t) {</span>
<span class="nc" id="L1753">				swingRenderer.getReflectionUI().logError(t);</span>
			}
		}
<span class="fc" id="L1756">	}</span>

	protected void updateDetailsArea(boolean refreshStructure) {
<span class="fc" id="L1759">		BufferedItemPosition singleSelection = getSingleSelection();</span>
<span class="fc bfc" id="L1760" title="All 2 branches covered.">		if (singleSelection != null) {</span>
<span class="fc" id="L1761">			IListTypeInfo listType = singleSelection.getContainingListType();</span>
<span class="pc bpc" id="L1762" title="1 of 4 branches missed.">			if (!getDetailsAccessMode().hasEmbeddedDetailsDisplayArea() || !listType.canViewItemDetails()) {</span>
<span class="fc" id="L1763">				singleSelection = null;</span>
			}
		}
<span class="fc bfc" id="L1766" title="All 4 branches covered.">		if ((detailsControlItemPosition == null) &amp;&amp; (singleSelection == null)) {</span>
<span class="fc" id="L1767">			return;</span>
		}
		try {
<span class="fc bfc" id="L1770" title="All 4 branches covered.">			if ((detailsControlItemPosition != null) &amp;&amp; (singleSelection != null)) {</span>
<span class="fc bfc" id="L1771" title="All 2 branches covered.">				if (!detailsControlItemPosition.equals(singleSelection)) {</span>
<span class="fc" id="L1772">					detailsControlItemPosition = singleSelection;</span>
<span class="fc" id="L1773">					detailsControlBuilder.setPosition(detailsControlItemPosition);</span>
				}
<span class="fc" id="L1775">				detailsControlBuilder.reloadValue(detailsControl, refreshStructure);</span>
<span class="fc" id="L1776">				return;</span>
			}
<span class="pc bpc" id="L1778" title="1 of 4 branches missed.">			if ((detailsControlItemPosition != null) &amp;&amp; (singleSelection == null)) {</span>
<span class="fc" id="L1779">				detailsControlItemPosition = null;</span>
<span class="fc" id="L1780">				detailsArea.removeAll();</span>
<span class="fc" id="L1781">				detailsControlBuilder = null;</span>
<span class="fc" id="L1782">				detailsControl = null;</span>
<span class="fc" id="L1783">				SwingRendererUtils.handleComponentSizeChange(detailsArea);</span>
<span class="fc" id="L1784">				return;</span>
			}

<span class="pc bpc" id="L1787" title="2 of 4 branches missed.">			if ((detailsControlItemPosition == null) &amp;&amp; (singleSelection != null)) {</span>
<span class="fc" id="L1788">				detailsControlItemPosition = singleSelection;</span>
<span class="fc" id="L1789">				detailsControlBuilder = createItemUIBuilder(detailsControlItemPosition);</span>
				try {
<span class="fc" id="L1791">					detailsControl = detailsControlBuilder.createEditorForm(true, false);</span>
<span class="pc" id="L1792">				} catch (Throwable t) {</span>
<span class="nc" id="L1793">					detailsControlItemPosition = null;</span>
<span class="nc" id="L1794">					detailsControlBuilder = null;</span>
<span class="nc" id="L1795">					throw new ReflectionUIError(t);</span>
				}
				/*
				 * A pre-selection must be done before each undo/redo modification to ensure
				 * that the replayed modification will affect the right item. Otherwise it may
				 * not be the case when the same detailsControlBuilder is reused to display
				 * multiple items (optimization): the modification would then affect the
				 * currently selected item instead of the one that was initially modified since
				 * the modification references the modified item through the current
				 * detailsControl.
				 */
<span class="fc" id="L1806">				detailsControl.getModificationStack().setPushFilter(new Filter&lt;IModification&gt;() {</span>
					@Override
					public IModification get(IModification undoModif) {
<span class="fc bfc" id="L1809" title="All 2 branches covered.">						if (undoModif.isVolatile()) {</span>
<span class="fc" id="L1810">							return undoModif;</span>
						}
<span class="fc" id="L1812">						Object oldItem = detailsControlItemPosition.getItem();</span>
<span class="fc" id="L1813">						Object newItem = detailsControlBuilder.getCurrentValue();</span>
<span class="fc" id="L1814">						IModification preSelection = new PreSelectItemModification(detailsControlItemPosition, newItem,</span>
<span class="fc" id="L1815">								oldItem, detailsControlBuilder, detailsControl);</span>
<span class="fc" id="L1816">						return ModificationStack.createCompositeModification(undoModif.getTitle(), UndoOrder.FIFO,</span>
<span class="fc" id="L1817">								preSelection, undoModif);</span>
					}
				});
<span class="fc" id="L1820">				detailsArea.setLayout(new BorderLayout());</span>
<span class="fc" id="L1821">				Component statusBar = detailsControl.getStatusBar();</span>
				{
<span class="fc" id="L1823">					detailsArea.add(statusBar, BorderLayout.SOUTH);</span>
				}
<span class="fc" id="L1825">				detailsArea.add(detailsControl, BorderLayout.CENTER);</span>
<span class="fc" id="L1826">				SwingRendererUtils.handleComponentSizeChange(detailsArea);</span>
<span class="fc" id="L1827">				SwingUtilities.invokeLater(new Runnable() {</span>
					@Override
					public void run() {
<span class="pc bpc" id="L1830" title="1 of 2 branches missed.">						if (detailsControlItemPosition != null) {</span>
<span class="fc" id="L1831">							scrollTo(detailsControlItemPosition);</span>
						}
<span class="fc" id="L1833">					}</span>
				});
<span class="fc" id="L1835">				return;</span>
			}
		} finally {
<span class="fc" id="L1838">			SwingRendererUtils.updateWindowMenu(this, swingRenderer);</span>
		}
<span class="nc" id="L1840">		throw new ReflectionUIError();</span>
	}

	protected void displayDetailsOnItemDoubleClick() {
<span class="fc" id="L1844">		treeTableComponent.addMouseListener(new MouseAdapter() {</span>
			@Override
			public void mouseClicked(MouseEvent me) {
<span class="nc bnc" id="L1847" title="All 2 branches missed.">				if (!getDetailsAccessMode().hasDetachedDetailsDisplayOption()) {</span>
<span class="nc" id="L1848">					return;</span>
				}
				try {
<span class="nc bnc" id="L1851" title="All 2 branches missed.">					if (me.getClickCount() != 2) {</span>
<span class="nc" id="L1852">						return;</span>
					}
<span class="nc" id="L1854">					int row = treeTableComponent.rowAtPoint(me.getPoint());</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">					if (row == -1) {</span>
<span class="nc" id="L1856">						return;</span>
					}
<span class="nc" id="L1858">					AbstractStandardListAction action = createOpenItemAction();</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">					if (!action.isValid()) {</span>
<span class="nc" id="L1860">						return;</span>
					}
<span class="nc" id="L1862">					action.actionPerformed(null);</span>
<span class="nc" id="L1863">				} catch (Throwable t) {</span>
<span class="nc" id="L1864">					swingRenderer.handleException(treeTableComponent, t);</span>
				}
<span class="nc" id="L1866">			}</span>
		});
<span class="fc" id="L1868">	}</span>

	protected ListControl getMasterListControl() {
<span class="fc" id="L1871">		FieldControlPlaceHolder fieldControlPlaceHolder = (FieldControlPlaceHolder) SwingUtilities</span>
<span class="fc" id="L1872">				.getAncestorOfClass(FieldControlPlaceHolder.class, this);</span>
<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">		if (fieldControlPlaceHolder == null) {</span>
<span class="nc" id="L1874">			return null;</span>
		}
<span class="fc" id="L1876">		ListControl masterListControl = (ListControl) SwingUtilities.getAncestorOfClass(ListControl.class,</span>
<span class="fc" id="L1877">				fieldControlPlaceHolder);</span>
<span class="fc bfc" id="L1878" title="All 2 branches covered.">		if (masterListControl == null) {</span>
<span class="fc" id="L1879">			return null;</span>
		}
<span class="fc" id="L1881">		BufferedItemPosition masterItemPosition = masterListControl.getSingleSelection();</span>
<span class="pc bpc" id="L1882" title="1 of 2 branches missed.">		if (masterItemPosition == null) {</span>
<span class="nc" id="L1883">			return null;</span>
		}
<span class="fc" id="L1885">		IListStructuralInfo masterStructuralInfo = masterItemPosition.getContainingListType().getStructuralInfo();</span>
<span class="pc bpc" id="L1886" title="1 of 2 branches missed.">		if (masterStructuralInfo == null) {</span>
<span class="nc" id="L1887">			return null;</span>
		}
<span class="fc" id="L1889">		if (!masterStructuralInfo.isSlave(fieldControlPlaceHolder.getObject(), fieldControlPlaceHolder.getField(),</span>
<span class="fc bfc" id="L1890" title="All 2 branches covered.">				masterItemPosition)) {</span>
<span class="fc" id="L1891">			return null;</span>
		}
<span class="fc" id="L1893">		return masterListControl;</span>
	}

	protected BufferedItemPosition toMasterListControlItemPosition(BufferedItemPosition itemPosition) {
<span class="nc" id="L1897">		ListControl masterListControl = getMasterListControl();</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">		if (masterListControl == null) {</span>
<span class="nc" id="L1899">			return null;</span>
		}
<span class="nc" id="L1901">		BufferedItemPosition masterSingleSelection = masterListControl.getSingleSelection();</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">		if (masterSingleSelection == null) {</span>
<span class="nc" id="L1903">			return null;</span>
		}
<span class="nc bnc" id="L1905" title="All 2 branches missed.">		if (itemPosition.isRoot()) {</span>
<span class="nc" id="L1906">			return masterSingleSelection.getSubItemPosition(itemPosition.getIndex());</span>
		} else {
<span class="nc" id="L1908">			return toMasterListControlItemPosition(itemPosition.getParentItemPosition())</span>
<span class="nc" id="L1909">					.getSubItemPosition(itemPosition.getIndex());</span>
		}
	}

	public Object[] getRootListRawValue() {
<span class="fc" id="L1914">		return itemPositionFactory.getRootItemPosition(-1).retrieveContainingListRawValue();</span>
	}

	public int getRootListSize() {
<span class="fc" id="L1918">		return itemPositionFactory.getRootItemPosition(-1).getContainingListSize();</span>
	}

	public BufferedItemPosition getActiveListItemPosition() {
<span class="nc" id="L1922">		BufferedItemPosition result = getSingleSelection();</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L1924">			result = itemPositionFactory.getRootItemPosition(-1);</span>
<span class="nc bnc" id="L1925" title="All 2 branches missed.">			if (result.getContainingListSize() &gt; 0) {</span>
<span class="nc" id="L1926">				result = result.getSibling(result.getContainingListSize() - 1);</span>
			}
		}
<span class="nc" id="L1929">		return result;</span>
	}

	protected ModificationStack getModificationStack() {
<span class="fc" id="L1933">		return input.getModificationStack();</span>
	}

	public void visitItems(IItemsVisitor iItemsVisitor) {
<span class="fc" id="L1937">		visitItems(iItemsVisitor, rootNode);</span>
<span class="fc" id="L1938">	}</span>

	protected VisitStatus visitItems(IItemsVisitor itemsVisitor, ItemNode currentNode) {
<span class="fc" id="L1941">		BufferedItemPosition currentItemPosition = getItemPositionByNode(currentNode);</span>
		final VisitStatus currentItemVisitStatus;
<span class="fc bfc" id="L1943" title="All 2 branches covered.">		if (currentItemPosition != null) {</span>
<span class="pc bpc" id="L1944" title="1 of 2 branches missed.">			if (SystemProperties.isDebugModeActive()) {</span>
<span class="nc" id="L1945">				checkVisit(currentItemPosition);</span>
			}
<span class="fc" id="L1947">			currentItemVisitStatus = itemsVisitor.visitItem(currentItemPosition);</span>
<span class="fc bfc" id="L1948" title="All 2 branches covered.">			if (currentItemVisitStatus == VisitStatus.TREE_VISIT_INTERRUPTED) {</span>
<span class="fc" id="L1949">				return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
			}
		} else {
<span class="fc" id="L1952">			currentItemVisitStatus = VisitStatus.VISIT_NOT_INTERRUPTED;</span>
		}
<span class="fc" id="L1954">		VisitStatus finalItemVisitStatus = currentItemVisitStatus;</span>
<span class="fc bfc" id="L1955" title="All 2 branches covered.">		if (currentItemVisitStatus != VisitStatus.SUBTREE_VISIT_INTERRUPTED) {</span>
<span class="fc bfc" id="L1956" title="All 2 branches covered.">			for (int i = 0; i &lt; currentNode.getChildCount(); i++) {</span>
<span class="fc" id="L1957">				ItemNode childNode = (ItemNode) currentNode.getChildAt(i);</span>
<span class="fc" id="L1958">				VisitStatus childItemVisitStatus = visitItems(itemsVisitor, childNode);</span>
<span class="fc bfc" id="L1959" title="All 2 branches covered.">				if (childItemVisitStatus == VisitStatus.TREE_VISIT_INTERRUPTED) {</span>
<span class="fc" id="L1960">					return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
				}
<span class="fc bfc" id="L1962" title="All 2 branches covered.">				if (childItemVisitStatus == VisitStatus.SUBTREE_VISIT_INTERRUPTED) {</span>
<span class="fc bfc" id="L1963" title="All 2 branches covered.">					if (finalItemVisitStatus == VisitStatus.VISIT_NOT_INTERRUPTED) {</span>
<span class="fc" id="L1964">						finalItemVisitStatus = VisitStatus.SUBTREE_VISIT_INTERRUPTED;</span>
					}
				}
			}
		}
<span class="fc" id="L1969">		return finalItemVisitStatus;</span>
	}

	public void visitItemsInBreadthFirstSearchMode(IItemsVisitor iItemsVisitor) {
<span class="fc" id="L1973">		visitItemsInBreadthFirstSearchMode(iItemsVisitor, rootNode, new LinkedList&lt;ListControl.ItemNode&gt;());</span>
<span class="fc" id="L1974">	}</span>

	protected VisitStatus visitItemsInBreadthFirstSearchMode(IItemsVisitor itemsVisitor, ItemNode currentNode,
			Queue&lt;ItemNode&gt; queue) {
<span class="fc" id="L1978">		BufferedItemPosition currentItemPosition = getItemPositionByNode(currentNode);</span>
		final VisitStatus currentItemVisitStatus;
<span class="fc bfc" id="L1980" title="All 2 branches covered.">		if (currentItemPosition != null) {</span>
<span class="pc bpc" id="L1981" title="1 of 2 branches missed.">			if (SystemProperties.isDebugModeActive()) {</span>
<span class="nc" id="L1982">				checkVisit(currentItemPosition);</span>
			}
<span class="fc" id="L1984">			currentItemVisitStatus = itemsVisitor.visitItem(currentItemPosition);</span>
<span class="fc bfc" id="L1985" title="All 2 branches covered.">			if (currentItemVisitStatus == VisitStatus.TREE_VISIT_INTERRUPTED) {</span>
<span class="fc" id="L1986">				return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
			}
		} else {
<span class="fc" id="L1989">			currentItemVisitStatus = VisitStatus.VISIT_NOT_INTERRUPTED;</span>
		}
<span class="pc bpc" id="L1991" title="1 of 2 branches missed.">		if (currentItemVisitStatus != VisitStatus.SUBTREE_VISIT_INTERRUPTED) {</span>
<span class="fc bfc" id="L1992" title="All 2 branches covered.">			for (int i = 0; i &lt; currentNode.getChildCount(); i++) {</span>
<span class="fc" id="L1993">				ItemNode childNode = (ItemNode) currentNode.getChildAt(i);</span>
<span class="fc" id="L1994">				queue.add(childNode);</span>
			}
		}
<span class="fc" id="L1997">		VisitStatus finalItemVisitStatus = currentItemVisitStatus;</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">		while (!queue.isEmpty()) {</span>
<span class="fc" id="L1999">			ItemNode nextNode = queue.poll();</span>
<span class="fc" id="L2000">			VisitStatus nextItemVisitStatus = visitItemsInBreadthFirstSearchMode(itemsVisitor, nextNode, queue);</span>
<span class="fc bfc" id="L2001" title="All 2 branches covered.">			if (nextItemVisitStatus == VisitStatus.TREE_VISIT_INTERRUPTED) {</span>
<span class="fc" id="L2002">				return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
			}
<span class="pc bpc" id="L2004" title="1 of 2 branches missed.">			if (nextItemVisitStatus == VisitStatus.SUBTREE_VISIT_INTERRUPTED) {</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">				if (finalItemVisitStatus == VisitStatus.VISIT_NOT_INTERRUPTED) {</span>
<span class="nc" id="L2006">					finalItemVisitStatus = VisitStatus.SUBTREE_VISIT_INTERRUPTED;</span>
				}
			}
		}
<span class="fc" id="L2010">		return finalItemVisitStatus;</span>
	}

	protected void checkVisit(BufferedItemPosition currentItemPosition) {
<span class="nc" id="L2014">		final int ITEM_POSITION_DEPTH_LIMIT = 100;</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">		if (currentItemPosition.getDepth() == ITEM_POSITION_DEPTH_LIMIT) {</span>
<span class="nc" id="L2016">			Runnable runnable = new Runnable() {</span>
				@Override
				public void run() {
<span class="nc" id="L2019">					if (!swingRenderer.openQuestionDialog(</span>
<span class="nc" id="L2020">							ListControl.this, &quot;Reached the depth &quot; + ITEM_POSITION_DEPTH_LIMIT</span>
<span class="nc" id="L2021">									+ &quot; for the tree control (title=&quot; + getRootListTitle() + &quot;). Continue ?&quot;,</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">							&quot;[DEBUG] WARNING&quot;)) {</span>
<span class="nc" id="L2023">						throw new ReflectionUIError(</span>
<span class="nc" id="L2024">								new InterruptedException(&quot;Reached the depth &quot; + ITEM_POSITION_DEPTH_LIMIT));</span>
					}
<span class="nc" id="L2026">				}</span>
			};
<span class="nc bnc" id="L2028" title="All 2 branches missed.">			if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L2029">				runnable.run();</span>
<span class="nc" id="L2030">			} else {</span>
<span class="nc" id="L2031">				SwingUtilities.invokeLater(runnable);</span>
			}
		}
<span class="nc" id="L2034">	}</span>

	@Override
	public boolean refreshUI(final boolean refreshStructure) {
<span class="fc" id="L2038">		listData.returningValue(listData.getValue(), new Runnable() {</span>
			@Override
			public void run() {
<span class="fc bfc" id="L2041" title="All 2 branches covered.">				if (refreshStructure) {</span>
<span class="fc" id="L2042">					removeAll();</span>
<span class="fc" id="L2043">					detailsMode = null;</span>
<span class="fc" id="L2044">					layoutControls();</span>
<span class="fc" id="L2045">					refreshTreeTableScrollPaneBorder();</span>
<span class="fc" id="L2046">					refreshTreeTableComponentStyle();</span>
<span class="fc" id="L2047">					refreshTreeTableComponentHeader();</span>
<span class="fc" id="L2048">					refreshRendrers();</span>
				}
<span class="fc" id="L2050">				restoringSelectionDespiteDataAlteration(new Runnable() {</span>
					@Override
					public void run() {
<span class="fc" id="L2053">						restoringExpandedPathsDespiteDataAlteration(new Runnable() {</span>
							@Override
							public void run() {
<span class="fc" id="L2056">								refreshItemPositionBuffers();</span>
<span class="fc" id="L2057">								refreshTreeTableModelAndControl(refreshStructure);</span>
<span class="fc" id="L2058">							}</span>
						});
<span class="fc" id="L2060">					}</span>
				});
<span class="fc bfc" id="L2062" title="All 2 branches covered.">				if (getDetailsAccessMode().hasEmbeddedDetailsDisplayArea()) {</span>
<span class="fc" id="L2063">					updateDetailsArea(refreshStructure);</span>
				}
<span class="fc" id="L2065">				updateToolbar();</span>
<span class="fc bfc" id="L2066" title="All 2 branches covered.">				if (refreshStructure) {</span>
<span class="fc" id="L2067">					SwingRendererUtils.handleComponentSizeChange(ListControl.this);</span>
				}
<span class="fc" id="L2069">			}</span>
		});
<span class="fc" id="L2071">		return true;</span>
	}

	protected void withoutSelectionTargetListenerEnabled(Runnable runnable) {
<span class="fc" id="L2075">		boolean oldSelectionAccessDataListenerEnabled = selectionTargetListenerEnabled;</span>
<span class="fc" id="L2076">		selectionTargetListenerEnabled = false;</span>
		try {
<span class="fc" id="L2078">			runnable.run();</span>
<span class="fc" id="L2079">		} finally {</span>
<span class="fc" id="L2080">			selectionTargetListenerEnabled = oldSelectionAccessDataListenerEnabled;</span>
		}
<span class="fc" id="L2082">	}</span>

	protected void withSelectionListenersDisabled(Runnable runnable) {
<span class="fc" id="L2085">		boolean oldSelectionListenersEnabled = selectionListenersEnabled;</span>
<span class="fc" id="L2086">		selectionListenersEnabled = false;</span>
		try {
<span class="fc" id="L2088">			runnable.run();</span>
<span class="fc" id="L2089">		} finally {</span>
<span class="fc" id="L2090">			selectionListenersEnabled = oldSelectionListenersEnabled;</span>
		}
<span class="fc" id="L2092">	}</span>

	protected void updateSelectionTargetOnSelectionChange() {
<span class="fc" id="L2095">		selectionListeners.add(new Listener&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
			@Override
			public void handle(List&lt;BufferedItemPosition&gt; event) {
<span class="fc bfc" id="L2098" title="All 2 branches covered.">				if (!selectionTargetListenerEnabled) {</span>
<span class="fc" id="L2099">					return;</span>
				}
<span class="fc" id="L2101">				updateSelectionTarget();</span>
<span class="fc" id="L2102">			}</span>
		});
<span class="fc" id="L2104">	}</span>

	protected void updateSelectionTarget() {
<span class="pc bpc" id="L2107" title="1 of 2 branches missed.">		if (selectionTargetData != null) {</span>
<span class="nc" id="L2108">			BufferedItemPosition selectedItemPosition = getSingleSelection();</span>
			Object value;
<span class="nc bnc" id="L2110" title="All 2 branches missed.">			if (selectedItemPosition == null) {</span>
<span class="nc" id="L2111">				value = null;</span>
<span class="nc" id="L2112">			} else {</span>
<span class="nc" id="L2113">				value = selectedItemPosition.getItem();</span>
			}
<span class="nc bnc" id="L2115" title="All 2 branches missed.">			if (!selectionTargetData.getType().supports(value)) {</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">				if (selectionTargetData.getType().supports(null)) {</span>
<span class="nc" id="L2117">					value = null;</span>
<span class="nc" id="L2118">				} else {</span>
					try {
<span class="nc" id="L2120">						value = ReflectionUIUtils.createDefaultInstance(selectionTargetData.getType());</span>
<span class="nc" id="L2121">					} catch (Throwable t) {</span>
<span class="nc" id="L2122">						throw new ReflectionUIError(</span>
<span class="nc" id="L2123">								&quot;Failed to get the value that would be used to update the selection target: &quot;</span>
<span class="nc" id="L2124">										+ t.toString(),</span>
<span class="nc" id="L2125">								t);</span>
					}
				}
			}
<span class="nc" id="L2129">			ReflectionUIUtils.setFieldValueThroughModificationStack(selectionTargetData, value, getModificationStack(),</span>
<span class="nc" id="L2130">					ReflectionUIUtils.getDebugLogListener(swingRenderer.getReflectionUI()));</span>
		}
<span class="fc" id="L2132">	}</span>

	protected boolean isSelectionUseful() {
<span class="nc bnc" id="L2135" title="All 2 branches missed.">		if (getDetailsAccessMode().hasEmbeddedDetailsDisplayArea()) {</span>
<span class="nc" id="L2136">			return true;</span>
		}

<span class="nc" id="L2139">		return false;</span>
	}

	protected void refreshItemPositionBuffers() {
<span class="fc" id="L2143">		itemPositionFactory.refreshAll();</span>
<span class="fc" id="L2144">	}</span>

	protected void refreshTreeTableScrollPaneBorder() {
<span class="fc" id="L2147">		SwingRendererUtils.showFieldCaptionOnBorder(listData, treeTableComponentScrollPane, new Accessor&lt;Border&gt;() {</span>
			@Override
			public Border get() {
<span class="fc bfc" id="L2150" title="All 2 branches covered.">				if (listData.getBorderColor() != null) {</span>
<span class="fc" id="L2151">					return BorderFactory.createLineBorder(SwingRendererUtils.getColor(listData.getBorderColor()));</span>
				} else {
<span class="fc" id="L2153">					return new ControlScrollPane().getBorder();</span>
				}
			}
<span class="fc" id="L2156">		}, swingRenderer);</span>
<span class="fc" id="L2157">	}</span>

	protected void refreshRendrers() {
<span class="fc" id="L2160">		treeTableComponent.setDefaultRenderer(Object.class, createTableCellRenderer());</span>
<span class="fc" id="L2161">		treeTableComponent.setTreeCellRenderer(createTreeCellRenderer());</span>
<span class="fc" id="L2162">	}</span>

	protected void refreshTreeTableComponentStyle() {
<span class="pc bpc" id="L2165" title="1 of 2 branches missed.">		if (listData.getEditorBackgroundColor() != null) {</span>
<span class="fc" id="L2166">			treeTableComponent.setBackground(SwingRendererUtils.getColor(listData.getEditorBackgroundColor()));</span>
<span class="fc" id="L2167">		} else {</span>
<span class="nc" id="L2168">			treeTableComponent.setBackground(new JXTreeTable().getBackground());</span>
		}
<span class="fc bfc" id="L2170" title="All 2 branches covered.">		if (listData.getEditorForegroundColor() != null) {</span>
<span class="fc" id="L2171">			treeTableComponent.setForeground(SwingRendererUtils.getColor(listData.getEditorForegroundColor()));</span>
<span class="fc" id="L2172">		} else {</span>
<span class="fc" id="L2173">			treeTableComponent.setForeground(new JXTreeTable().getForeground());</span>
		}
<span class="pc bpc" id="L2175" title="1 of 2 branches missed.">		if (listData.getEditorCustomFontResourcePath() != null) {</span>
<span class="nc" id="L2176">			treeTableComponent.setFont(SwingRendererUtils</span>
<span class="nc" id="L2177">					.loadFontThroughCache(listData.getEditorCustomFontResourcePath(),</span>
<span class="nc" id="L2178">							ReflectionUIUtils.getErrorLogListener(swingRenderer.getReflectionUI()), swingRenderer)</span>
<span class="nc" id="L2179">					.deriveFont(treeTableComponent.getFont().getStyle(), treeTableComponent.getFont().getSize()));</span>
<span class="nc" id="L2180">		} else {</span>
<span class="fc" id="L2181">			treeTableComponent.setFont(new JXTreeTable().getFont());</span>
		}
<span class="fc" id="L2183">	}</span>

	protected void refreshTreeTableComponentHeader() {
<span class="pc bpc" id="L2186" title="1 of 2 branches missed.">		if (listData.getNonEditableBackgroundColor() != null) {</span>
<span class="nc" id="L2187">			treeTableComponent.getTableHeader()</span>
<span class="nc" id="L2188">					.setBackground(SwingRendererUtils.getColor(listData.getNonEditableBackgroundColor()));</span>
<span class="nc" id="L2189">		} else {</span>
<span class="pc bpc" id="L2190" title="1 of 2 branches missed.">			if (swingRenderer.getMainBackgroundColor() != null) {</span>
<span class="fc" id="L2191">				treeTableComponent.getTableHeader().setBackground(swingRenderer.getMainBackgroundColor());</span>
<span class="fc" id="L2192">			} else {</span>
<span class="nc" id="L2193">				treeTableComponent.getTableHeader().setBackground(new JXTreeTable().getTableHeader().getBackground());</span>
			}
		}
<span class="fc bfc" id="L2196" title="All 2 branches covered.">		if (listData.getNonEditableForegroundColor() != null) {</span>
<span class="fc" id="L2197">			treeTableComponent.getTableHeader()</span>
<span class="fc" id="L2198">					.setForeground(SwingRendererUtils.getColor(listData.getNonEditableForegroundColor()));</span>
<span class="fc" id="L2199">		} else {</span>
<span class="fc" id="L2200">			treeTableComponent.getTableHeader().setForeground(new JXTreeTable().getTableHeader().getForeground());</span>
		}
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">		if (listData.getLabelCustomFontResourcePath() != null) {</span>
<span class="nc" id="L2203">			treeTableComponent.getTableHeader()</span>
<span class="nc" id="L2204">					.setFont(SwingRendererUtils.loadFontThroughCache(listData.getLabelCustomFontResourcePath(),</span>
<span class="nc" id="L2205">							ReflectionUIUtils.getErrorLogListener(swingRenderer.getReflectionUI()), swingRenderer)</span>
<span class="nc" id="L2206">							.deriveFont(treeTableComponent.getTableHeader().getFont().getStyle(),</span>
<span class="nc" id="L2207">									treeTableComponent.getTableHeader().getFont().getSize()));</span>
<span class="nc" id="L2208">		} else {</span>
<span class="fc" id="L2209">			treeTableComponent.getTableHeader().setFont(new JTableHeader().getFont());</span>
		}
<span class="fc" id="L2211">	}</span>

	@Override
	public boolean requestCustomFocus() {
<span class="fc bfc" id="L2215" title="All 2 branches covered.">		if (selectionTargetData == null) {</span>
<span class="fc" id="L2216">			setDefaultSelection();</span>
		}
<span class="fc bfc" id="L2218" title="All 2 branches covered.">		if (SwingRendererUtils.requestAnyComponentFocus(treeTableComponent, swingRenderer)) {</span>
<span class="fc" id="L2219">			return true;</span>
		}
<span class="fc" id="L2221">		return false;</span>
	}

	@Override
	public void validateControlData(ValidationSession session) throws Exception {
<span class="fc" id="L2226">		final Map&lt;BufferedItemPosition, Exception&gt; validitionErrorByItemPosition = new HashMap&lt;BufferedItemPosition, Exception&gt;();</span>
<span class="fc" id="L2227">		visitItems(new IItemsVisitor() {</span>
			@Override
			public VisitStatus visitItem(BufferedItemPosition itemPosition) {
<span class="fc" id="L2230">				if (swingRenderer.getReflectionUI().getValidationErrorRegistry()</span>
<span class="fc bfc" id="L2231" title="All 2 branches covered.">						.isValidationCancelled(Thread.currentThread())) {</span>
<span class="fc" id="L2232">					return VisitStatus.TREE_VISIT_INTERRUPTED;</span>
				}
<span class="fc bfc" id="L2234" title="All 2 branches covered.">				if (!itemPosition.getContainingListType().isItemNodeValidityDetectionEnabled(itemPosition)) {</span>
<span class="fc" id="L2235">					return VisitStatus.SUBTREE_VISIT_INTERRUPTED;</span>
				}
<span class="fc" id="L2237">				ItemUIBuilder itemUIBuilder = createItemUIBuilder(itemPosition);</span>
				try {
<span class="fc" id="L2239">					itemUIBuilder.performHeadlessFormValidation(session);</span>
<span class="fc" id="L2240">				} catch (Exception e) {</span>
<span class="fc" id="L2241">					validitionErrorByItemPosition.put(itemPosition, e);</span>
				}
<span class="fc" id="L2243">				return VisitStatus.VISIT_NOT_INTERRUPTED;</span>
			}
		});
<span class="fc" id="L2246">		SwingUtilities.invokeLater(new Runnable() {</span>
			@Override
			public void run() {
<span class="fc" id="L2249">				refreshRendrers();</span>
<span class="fc" id="L2250">				treeTableComponent.repaint();</span>
<span class="fc" id="L2251">			}</span>
		});
<span class="fc" id="L2253">		if (swingRenderer.getReflectionUI().getValidationErrorRegistry()</span>
<span class="fc bfc" id="L2254" title="All 2 branches covered.">				.isValidationCancelled(Thread.currentThread())) {</span>
<span class="fc" id="L2255">			return;</span>
		}
<span class="fc bfc" id="L2257" title="All 2 branches covered.">		if (validitionErrorByItemPosition.size() &gt; 0) {</span>
<span class="fc" id="L2258">			throw new ValidationErrorWrapper(null, new ListValidationError(validitionErrorByItemPosition));</span>
		}
<span class="fc" id="L2260">	}</span>

	protected String getDisplayPath(BufferedItemPosition itemPosition) {
<span class="nc" id="L2263">		return MiscUtils</span>
<span class="nc" id="L2264">				.getReverse(MiscUtils.getAdded(Collections.singletonList(itemPosition), itemPosition.getAncestors()))</span>
<span class="nc" id="L2265">				.stream().map(eachItemPosition -&gt; getCellValue(findNode((BufferedItemPosition) eachItemPosition), 0))</span>
<span class="nc" id="L2266">				.collect(Collectors.joining(&quot; / &quot;));</span>
	}

	@Override
	public void addMenuContributions(MenuModel menuModel) {
<span class="fc bfc" id="L2271" title="All 2 branches covered.">		if (detailsControl != null) {</span>
<span class="fc" id="L2272">			detailsControl.addMenuContributionTo(menuModel);</span>
		}
<span class="fc" id="L2274">	}</span>

	protected void refreshTreeTableModelAndControl(boolean refreshStructure) {
<span class="fc" id="L2277">		Runnable action = new Runnable() {</span>
			@Override
			public void run() {
<span class="fc" id="L2280">				valuesByNode.clear();</span>
<span class="fc" id="L2281">				rootNode = createRootNode();</span>
<span class="fc" id="L2282">				treeTableComponent.setTreeTableModel(createTreeTableModel());</span>
<span class="fc" id="L2283">			}</span>
		};
<span class="fc bfc" id="L2285" title="All 2 branches covered.">		if (refreshStructure) {</span>
<span class="fc" id="L2286">			action.run();</span>
<span class="fc" id="L2287">			initializeColumnWidths();</span>
<span class="fc" id="L2288">		} else {</span>
<span class="fc" id="L2289">			restoringColumnWidthsAsMuchAsPossible(action);</span>
		}
<span class="pc bpc" id="L2291" title="1 of 2 branches missed.">		treeTableComponent.setOpaque(itemPositionFactory.getRootListValue() != null);</span>
<span class="fc" id="L2292">	}</span>

	protected void initializeColumnWidths() {
<span class="fc" id="L2295">		TableColumnModel columnModel = treeTableComponent.getColumnModel();</span>
		{
<span class="fc" id="L2297">			List&lt;IColumnInfo&gt; columnInfos = getRootStructuralInfo().getColumns();</span>
<span class="fc bfc" id="L2298" title="All 2 branches covered.">			for (int i = 0; i &lt; columnInfos.size(); i++) {</span>
<span class="fc" id="L2299">				IColumnInfo columnInfo = columnInfos.get(i);</span>
<span class="fc" id="L2300">				TableColumn column = columnModel.getColumn(i);</span>
<span class="fc" id="L2301">				column.setPreferredWidth(columnInfo.getMinimalCharacterCount()</span>
<span class="fc" id="L2302">						* SwingRendererUtils.getStandardCharacterWidth(treeTableComponent));</span>
			}
		}
<span class="fc" id="L2305">	}</span>

	protected void restoringColumnWidthsAsMuchAsPossible(Runnable runnable) {
<span class="fc" id="L2308">		Map&lt;String, Integer&gt; preferredWidthByColumnName = new HashMap&lt;String, Integer&gt;();</span>
<span class="fc" id="L2309">		TableColumnModel columnModel = treeTableComponent.getColumnModel();</span>
<span class="fc bfc" id="L2310" title="All 2 branches covered.">		for (int i = 0; i &lt; columnModel.getColumnCount(); i++) {</span>
<span class="fc" id="L2311">			TableColumn col = columnModel.getColumn(i);</span>
<span class="fc" id="L2312">			preferredWidthByColumnName.put(col.getHeaderValue().toString(), col.getPreferredWidth());</span>
		}

<span class="fc" id="L2315">		runnable.run();</span>

<span class="fc" id="L2317">		columnModel = treeTableComponent.getColumnModel();</span>
<span class="fc" id="L2318">		List&lt;IColumnInfo&gt; columnInfos = getRootStructuralInfo().getColumns();</span>
<span class="fc bfc" id="L2319" title="All 2 branches covered.">		for (int i = 0; i &lt; columnModel.getColumnCount(); i++) {</span>
<span class="fc" id="L2320">			TableColumn col = columnModel.getColumn(i);</span>
<span class="fc" id="L2321">			IColumnInfo columnInfo = columnInfos.get(i);</span>
<span class="fc" id="L2322">			Integer knownPreferredWidth = preferredWidthByColumnName.get(col.getHeaderValue().toString());</span>
<span class="pc bpc" id="L2323" title="1 of 2 branches missed.">			if (knownPreferredWidth != null) {</span>
<span class="fc" id="L2324">				col.setPreferredWidth(knownPreferredWidth);</span>
<span class="fc" id="L2325">			} else {</span>
<span class="nc" id="L2326">				col.setPreferredWidth(columnInfo.getMinimalCharacterCount()</span>
<span class="nc" id="L2327">						* SwingRendererUtils.getStandardCharacterWidth(treeTableComponent));</span>
			}
		}
<span class="fc" id="L2330">	}</span>

	protected void preventingIntermediarySelectionEvents(Runnable runnable) {
<span class="fc" id="L2333">		Multiset&lt;Object&gt; oldSelectionBag = HashMultiset.create();</span>
<span class="fc bfc" id="L2334" title="All 2 branches covered.">		for (BufferedItemPosition itemPosition : getSelection()) {</span>
<span class="pc bpc" id="L2335" title="1 of 2 branches missed.">			if (itemPosition.isStable()) {</span>
<span class="fc" id="L2336">				oldSelectionBag.add(itemPosition);</span>
<span class="fc" id="L2337">			} else {</span>
<span class="nc" id="L2338">				List&lt;Object&gt; itemAndAncestors = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L2339">				itemAndAncestors.add(itemPosition.getItem());</span>
<span class="nc" id="L2340">				itemAndAncestors.addAll(ReflectionUIUtils.collectItemAncestors(itemPosition));</span>
<span class="nc" id="L2341">				oldSelectionBag.add(itemAndAncestors);</span>
			}
		}
<span class="fc" id="L2344">		withSelectionListenersDisabled(new Runnable() {</span>
			@Override
			public void run() {
<span class="fc" id="L2347">				runnable.run();</span>
<span class="fc" id="L2348">			}</span>
		});
<span class="fc" id="L2350">		Multiset&lt;Object&gt; newSelectionBag = HashMultiset.create();</span>
<span class="fc bfc" id="L2351" title="All 2 branches covered.">		for (BufferedItemPosition itemPosition : getSelection()) {</span>
<span class="pc bpc" id="L2352" title="1 of 2 branches missed.">			if (itemPosition.isStable()) {</span>
<span class="fc" id="L2353">				newSelectionBag.add(itemPosition);</span>
<span class="fc" id="L2354">			} else {</span>
<span class="nc" id="L2355">				List&lt;Object&gt; itemAndAncestors = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L2356">				itemAndAncestors.add(itemPosition.getItem());</span>
<span class="nc" id="L2357">				itemAndAncestors.addAll(ReflectionUIUtils.collectItemAncestors(itemPosition));</span>
<span class="nc" id="L2358">				newSelectionBag.add(itemAndAncestors);</span>
			}
		}
<span class="fc bfc" id="L2361" title="All 2 branches covered.">		if (!newSelectionBag.equals(oldSelectionBag)) {</span>
<span class="fc" id="L2362">			fireSelectionEvent();</span>
		}
<span class="fc" id="L2364">	}</span>

	protected void restoringSelectionDespiteDataAlteration(Runnable runnable) {
<span class="fc" id="L2367">		final List&lt;BufferedItemPosition&gt; wereSelectedPositions = getSelection();</span>
<span class="fc" id="L2368">		final List&lt;Object&gt; wereSelected = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L2369">		final List&lt;List&lt;Object&gt;&gt; wereSelectedAncestorLists = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
<span class="fc bfc" id="L2370" title="All 2 branches covered.">		for (int i = 0; i &lt; wereSelectedPositions.size(); i++) {</span>
<span class="fc" id="L2371">			BufferedItemPosition wasSelectedPosition = wereSelectedPositions.get(i);</span>
<span class="fc" id="L2372">			wereSelected.add(wasSelectedPosition.getItem());</span>
<span class="fc" id="L2373">			wereSelectedAncestorLists.add(ReflectionUIUtils.collectItemAncestors(wasSelectedPosition));</span>
		}
<span class="fc" id="L2375">		preventingIntermediarySelectionEvents(new Runnable() {</span>
			public void run() {
<span class="fc" id="L2377">				runnable.run();</span>
<span class="fc" id="L2378">				List&lt;BufferedItemPosition&gt; willBeSelectedPositions = ReflectionUIUtils</span>
<span class="fc" id="L2379">						.actualizeItemPositions(wereSelectedPositions, wereSelected, wereSelectedAncestorLists);</span>
<span class="fc" id="L2380">				setSelection(willBeSelectedPositions);</span>
<span class="fc" id="L2381">			}</span>
		});
<span class="fc" id="L2383">	}</span>

	protected void restoringExpandedPathsDespiteDataAlteration(Runnable runnable) {
<span class="fc" id="L2386">		List&lt;BufferedItemPosition&gt; wereExpandedPositions = getExpandedItemPositions(null);</span>
<span class="fc" id="L2387">		List&lt;Object&gt; wereExpanded = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L2388">		List&lt;List&lt;Object&gt;&gt; wereExpandedAncestorLists = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
<span class="fc bfc" id="L2389" title="All 2 branches covered.">		for (int i = 0; i &lt; wereExpandedPositions.size(); i++) {</span>
<span class="fc" id="L2390">			BufferedItemPosition wasExpandedPosition = wereExpandedPositions.get(i);</span>
<span class="fc" id="L2391">			wereExpanded.add(wasExpandedPosition.getItem());</span>
<span class="fc" id="L2392">			wereExpandedAncestorLists.add(ReflectionUIUtils.collectItemAncestors(wasExpandedPosition));</span>
		}
<span class="fc" id="L2394">		runnable.run();</span>
<span class="fc" id="L2395">		collapseAllItemPositions();</span>
<span class="fc" id="L2396">		List&lt;BufferedItemPosition&gt; willBeExpandedPositions = ReflectionUIUtils</span>
<span class="fc" id="L2397">				.actualizeItemPositions(wereExpandedPositions, wereExpanded, wereExpandedAncestorLists);</span>
<span class="fc bfc" id="L2398" title="All 2 branches covered.">		for (BufferedItemPosition itemPosition : willBeExpandedPositions) {</span>
<span class="fc" id="L2399">			expandItemPosition(itemPosition);</span>
		}
<span class="fc" id="L2401">	}</span>

	protected class ItemNode extends AbstractLazyTreeNode {

		protected static final long serialVersionUID = 1L;
		protected BufferedItemPosition currentItemPosition;
<span class="fc" id="L2407">		protected boolean childrenLoaded = false;;</span>

<span class="fc" id="L2409">		public ItemNode(BufferedItemPosition currentItemPosition) {</span>
<span class="fc" id="L2410">			this.currentItemPosition = currentItemPosition;</span>
<span class="fc" id="L2411">			setUserObject(currentItemPosition);</span>
<span class="fc" id="L2412">		}</span>

		@Override
		protected List&lt;AbstractLazyTreeNode&gt; createChildrenNodes() {
<span class="fc" id="L2416">			List&lt;AbstractLazyTreeNode&gt; result = new ArrayList&lt;AbstractLazyTreeNode&gt;();</span>
<span class="fc bfc" id="L2417" title="All 2 branches covered.">			if (currentItemPosition == null) {</span>
<span class="fc bfc" id="L2418" title="All 2 branches covered.">				for (int i = 0; i &lt; itemPositionFactory.getRootItemPosition(-1).getContainingListSize(); i++) {</span>
<span class="fc" id="L2419">					BufferedItemPosition rootItemPosition = itemPositionFactory.getRootItemPosition(i);</span>
<span class="fc" id="L2420">					ItemNode node = new ItemNode(rootItemPosition);</span>
<span class="fc" id="L2421">					result.add(node);</span>
				}
<span class="fc" id="L2423">			} else {</span>
<span class="fc bfc" id="L2424" title="All 2 branches covered.">				for (BufferedItemPosition childItemPosition : currentItemPosition.getSubItemPositions()) {</span>
<span class="fc" id="L2425">					ItemNode node = new ItemNode(childItemPosition);</span>
<span class="fc" id="L2426">					result.add(node);</span>
				}
			}
<span class="fc" id="L2429">			return result;</span>
		}

	}

	protected class RefreshModification implements IModification {
		protected Accessor&lt;List&lt;BufferedItemPosition&gt;&gt; newSelectionGetter;
		protected Accessor&lt;List&lt;BufferedItemPosition&gt;&gt; oldSelectionGetter;

<span class="fc" id="L2438">		public RefreshModification(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt; newSelectionGetter,</span>
<span class="fc" id="L2439">				Accessor&lt;List&lt;BufferedItemPosition&gt;&gt; oldSelectionGetter) {</span>
<span class="fc" id="L2440">			this.newSelectionGetter = newSelectionGetter;</span>
<span class="fc" id="L2441">			this.oldSelectionGetter = oldSelectionGetter;</span>
<span class="fc" id="L2442">		}</span>

		@Override
		public IModification applyAndGetOpposite(ModificationStack modificationStack) {
<span class="fc" id="L2446">			preventingIntermediarySelectionEvents(new Runnable() {</span>
				@Override
				public void run() {
<span class="fc" id="L2449">					restoringExpandedPathsDespiteDataAlteration(new Runnable() {</span>
						@Override
						public void run() {
<span class="pc bpc" id="L2452" title="1 of 2 branches missed.">							if (ListControl.this.buffersRefreshedAfterModification) {</span>
<span class="nc" id="L2453">								refreshItemPositionBuffers();</span>
							}
<span class="fc" id="L2455">							refreshTreeTableModelAndControl(false);</span>
<span class="fc" id="L2456">						}</span>
					});
<span class="pc bpc" id="L2458" title="1 of 2 branches missed.">					if (newSelectionGetter != null) {</span>
<span class="fc" id="L2459">						List&lt;BufferedItemPosition&gt; newSelection = newSelectionGetter.get();</span>
<span class="pc bpc" id="L2460" title="1 of 2 branches missed.">						if (newSelection != null) {</span>
<span class="fc" id="L2461">							setSelection(newSelection);</span>
						}
					}
<span class="fc" id="L2464">				}</span>
			});
<span class="fc" id="L2466">			return new RefreshModification(oldSelectionGetter, newSelectionGetter);</span>
		}

		@Override
		public String toString() {
<span class="fc" id="L2471">			return getTitle();</span>
		}

		@Override
		public String getTitle() {
<span class="fc" id="L2476">			return &quot;Refresh Structure And Select Item(s)&quot;;</span>
		}

		@Override
		public boolean isNull() {
<span class="fc" id="L2481">			return false;</span>
		}

		@Override
		public boolean isVolatile() {
<span class="fc" id="L2486">			return false;</span>
		}

		@Override
		public boolean isComposite() {
<span class="nc" id="L2491">			return false;</span>
		}
	}

	protected class TreeTable extends JXTreeTable {
		private static final long serialVersionUID = 1L;

<span class="fc" id="L2498">		public TreeTable() {</span>
<span class="fc" id="L2499">		}</span>

		@Override
		public String getToolTipText(MouseEvent event) {
			try {
<span class="nc" id="L2504">				return super.getToolTipText(event);</span>
<span class="nc" id="L2505">			} catch (Throwable t) {</span>
<span class="nc" id="L2506">				return null;</span>
			}
		}
	}

	protected class PreSelectItemModification extends AbstractModification {

		protected BufferedItemPosition currentPosition;
		protected Object doItem;
		protected Object undoItem;
		protected List&lt;Object&gt; itemAncestors;
		protected ItemUIBuilder detailsControlBuilder;
		protected Form detailsControl;

<span class="fc" id="L2520">		public PreSelectItemModification(BufferedItemPosition currentPosition, Object doItem, Object undoItem,</span>
<span class="fc" id="L2521">				ItemUIBuilder detailsControlBuilder, Form detailsControl) {</span>
<span class="fc" id="L2522">			this.currentPosition = currentPosition;</span>
<span class="fc" id="L2523">			this.doItem = doItem;</span>
<span class="fc" id="L2524">			this.undoItem = undoItem;</span>
<span class="fc" id="L2525">			this.itemAncestors = ReflectionUIUtils.collectItemAncestors(currentPosition);</span>
<span class="fc" id="L2526">			this.detailsControlBuilder = detailsControlBuilder;</span>
<span class="fc" id="L2527">			this.detailsControl = detailsControl;</span>
<span class="fc" id="L2528">		}</span>

		@Override
		public String getTitle() {
<span class="nc" id="L2532">			return &quot;Item Selection&quot;;</span>
		}

		@Override
		protected Runnable createDoJob() {
<span class="nc" id="L2537">			return createAnyJob(doItem);</span>
		}

		@Override
		protected Runnable createUndoJob() {
<span class="nc" id="L2542">			return createAnyJob(undoItem);</span>
		}

		@Override
		protected Runnable createRedoJob() {
<span class="nc" id="L2547">			return createAnyJob(doItem);</span>
		}

		protected Runnable createAnyJob(final Object currentItem) {
<span class="nc" id="L2551">			return new Runnable() {</span>
				@Override
				public void run() {
<span class="nc" id="L2554">					Object[] containingListRawValue = currentPosition.retrieveContainingListRawValue();</span>
<span class="nc" id="L2555">					List&lt;BufferedItemPosition&gt; toSelect = ReflectionUIUtils.actualizeItemPositions(</span>
<span class="nc" id="L2556">							Collections.singletonList(currentPosition), Collections.singletonList(currentItem),</span>
<span class="nc" id="L2557">							Collections.singletonList(itemAncestors));</span>
<span class="nc" id="L2558">					setSelection(toSelect);</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">					if (!detailsControlItemPosition.equals(getSingleSelection())) {</span>
<span class="nc" id="L2560">						updateDetailsArea(true);</span>
					}
					/*
					 * Now we are sure that the item that must be modified is selected. But it may
					 * be a copy that is just equal. To ensure that the item that will be committed
					 * (currentItem) is the one that is referenced by the details modification
					 * object, we must update its reference in the detailsControl. PROBLEM: the
					 * details modification object may reference a &quot;dead&quot; detailsControl (rebuilt at
					 * some time) preventing from updating this reference. That is why the right
					 * detailsControlBuilder and its detailsControl are stored in this class.
					 */
<span class="nc bnc" id="L2571" title="All 2 branches missed.">					if (detailsControlBuilder.getCurrentValue() != currentItem) {</span>
<span class="nc" id="L2572">						containingListRawValue[currentPosition.getIndex()] = currentItem;</span>
<span class="nc" id="L2573">						currentPosition.changeContainingListBuffer(currentPosition.retrieveContainingListValue(),</span>
<span class="nc" id="L2574">								containingListRawValue);</span>
<span class="nc" id="L2575">						detailsControlBuilder.reloadValue(detailsControl, false);</span>
					}
<span class="nc" id="L2577">				}</span>
			};
		}

	}

	protected class ItemTableCellRenderer implements TableCellRenderer {

<span class="fc" id="L2585">		protected TableCellRenderer defaultRenderer = new DefaultTableCellRenderer();</span>

<span class="fc" id="L2587">		public ItemTableCellRenderer() {</span>
<span class="fc" id="L2588">		}</span>

		@Override
		public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus,
				int row, int column) {
<span class="fc" id="L2593">			JLabel label = (JLabel) defaultRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus,</span>
<span class="fc" id="L2594">					row, column);</span>
<span class="fc" id="L2595">			row = treeTableComponent.convertRowIndexToModel(row);</span>
<span class="fc" id="L2596">			TreePath path = treeTableComponent.getPathForRow(row);</span>
<span class="pc bpc" id="L2597" title="1 of 2 branches missed.">			if (path != null) {</span>
<span class="fc" id="L2598">				ItemNode node = (ItemNode) path.getLastPathComponent();</span>
<span class="fc" id="L2599">				customizeCellRendererComponent(label, node, row, column, isSelected, hasFocus);</span>
			}
<span class="fc" id="L2601">			return label;</span>
		}

	}

	protected class ItemTreeCellRenderer implements TreeCellRenderer {

<span class="fc" id="L2608">		protected TreeCellRenderer defaultRenderer = new DefaultTreeCellRenderer();</span>
<span class="fc" id="L2609">		protected JLabel component = new JLabel();</span>

<span class="fc" id="L2611">		public ItemTreeCellRenderer() {</span>
<span class="fc" id="L2612">		}</span>

		@Override
		public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded,
				boolean isLeaf, int row, boolean focused) {
<span class="fc" id="L2617">			JLabel defaultComponent = (JLabel) defaultRenderer.getTreeCellRendererComponent(tree, value, selected,</span>
<span class="fc" id="L2618">					expanded, isLeaf, row, focused);</span>
<span class="fc" id="L2619">			component.setForeground(defaultComponent.getForeground());</span>
<span class="fc" id="L2620">			component.setBackground(defaultComponent.getBackground());</span>
<span class="pc bpc" id="L2621" title="1 of 2 branches missed.">			if (listData.getEditorCustomFontResourcePath() != null) {</span>
<span class="nc" id="L2622">				component.setFont(SwingRendererUtils</span>
<span class="nc" id="L2623">						.loadFontThroughCache(listData.getEditorCustomFontResourcePath(),</span>
<span class="nc" id="L2624">								ReflectionUIUtils.getErrorLogListener(swingRenderer.getReflectionUI()), swingRenderer)</span>
<span class="nc" id="L2625">						.deriveFont(component.getFont().getStyle(), component.getFont().getSize()));</span>
			}
<span class="fc" id="L2627">			component.setOpaque(false);</span>
<span class="fc" id="L2628">			customizeCellRendererComponent(component, (ItemNode) value, row, 0, selected, focused);</span>
<span class="fc" id="L2629">			return component;</span>
		}

	}

<span class="fc" id="L2634">	protected abstract class AbstractStandardListAction extends AbstractAction {</span>

		protected static final long serialVersionUID = 1L;

		protected abstract boolean prepare();

		protected abstract void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder);

		protected abstract String getActionTitle();

		protected abstract String getCompositeModificationTitle();

		protected abstract boolean isValid();

		@Override
		public Object getValue(String key) {
<span class="fc bfc" id="L2650" title="All 2 branches covered.">			if (Action.NAME.equals(key)) {</span>
<span class="fc" id="L2651">				return swingRenderer.prepareMessageToDisplay(getActionTitle());</span>
<span class="fc bfc" id="L2652" title="All 2 branches covered.">			} else if (Action.SHORT_DESCRIPTION.equals(key)) {</span>
<span class="fc" id="L2653">				String result = getActionDescription();</span>
<span class="pc bpc" id="L2654" title="1 of 2 branches missed.">				if (result != null) {</span>
<span class="nc" id="L2655">					result = swingRenderer.prepareMessageToDisplay(result);</span>
				}
<span class="fc" id="L2657">				return result;</span>
			} else {
<span class="fc" id="L2659">				return super.getValue(key);</span>
			}
		}

		protected String getActionDescription() {
<span class="fc" id="L2664">			return null;</span>
		}

		@Override
		public boolean isEnabled() {
<span class="fc" id="L2669">			return isValid();</span>
		}

		@Override
		public void actionPerformed(ActionEvent e) {
<span class="fc" id="L2674">			preventingIntermediarySelectionEvents(new Runnable() {</span>
				@Override
				public void run() {
					try {
<span class="fc" id="L2678">						final Accessor&lt;List&lt;BufferedItemPosition&gt;&gt; defaultPostSelectionGetter = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
<span class="fc" id="L2679">							List&lt;BufferedItemPosition&gt; oldItemPositions = getSelection();</span>
<span class="fc" id="L2680">							List&lt;Object&gt; oldItems = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L2681">							List&lt;List&lt;Object&gt;&gt; oldItemAncestorLists = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
							{
<span class="fc bfc" id="L2683" title="All 2 branches covered.">								for (BufferedItemPosition itemPosition : oldItemPositions) {</span>
<span class="fc" id="L2684">									oldItems.add(itemPosition.getItem());</span>
<span class="fc" id="L2685">									oldItemAncestorLists.add(ReflectionUIUtils.collectItemAncestors(itemPosition));</span>
								}
							}

							@Override
							public List&lt;BufferedItemPosition&gt; get() {
<span class="fc" id="L2691">								return ReflectionUIUtils.actualizeItemPositions(oldItemPositions, oldItems,</span>
<span class="fc" id="L2692">										oldItemAncestorLists);</span>
							}
						};
<span class="pc bpc" id="L2695" title="1 of 2 branches missed.">						if (!prepare()) {</span>
<span class="nc" id="L2696">							return;</span>
						}
<span class="fc" id="L2698">						final String modifTitle = getCompositeModificationTitle();</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L2700">						final Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder = new Accessor[] {</span>
<span class="fc" id="L2701">								defaultPostSelectionGetter };</span>
<span class="fc bfc" id="L2702" title="All 2 branches covered.">						if (modifTitle == null) {</span>
<span class="fc" id="L2703">							perform(postSelectionGetterHolder);</span>
<span class="fc" id="L2704">							new RefreshModification(postSelectionGetterHolder[0], null)</span>
<span class="fc" id="L2705">									.applyAndGetOpposite(ModificationStack.DUMMY_MODIFICATION_STACK);</span>
<span class="fc" id="L2706">						} else {</span>
<span class="fc" id="L2707">							final ModificationStack modifStack = getModificationStack();</span>
<span class="fc" id="L2708">							modifStack.insideComposite(modifTitle, UndoOrder.FIFO, new Accessor&lt;Boolean&gt;() {</span>
								@Override
								public Boolean get() {
<span class="fc" id="L2711">									if (modifStack.insideComposite(modifTitle + &quot; (without list control update)&quot;,</span>
<span class="fc" id="L2712">											UndoOrder.getNormal(), new Accessor&lt;Boolean&gt;() {</span>
												@Override
												public Boolean get() {
<span class="fc" id="L2715">													perform(postSelectionGetterHolder);</span>
<span class="fc" id="L2716">													return true;</span>
												}
<span class="fc bfc" id="L2718" title="All 2 branches covered.">											}, listData.isTransient())) {</span>
<span class="fc" id="L2719">										modifStack.apply(new RefreshModification(postSelectionGetterHolder[0],</span>
<span class="fc" id="L2720">												defaultPostSelectionGetter));</span>
<span class="fc" id="L2721">										return true;</span>
									} else {
<span class="fc" id="L2723">										new RefreshModification(postSelectionGetterHolder[0], null)</span>
<span class="fc" id="L2724">												.applyAndGetOpposite(ModificationStack.DUMMY_MODIFICATION_STACK);</span>
<span class="fc" id="L2725">										return modifStack.wasInvalidated();</span>
									}
								}
<span class="fc" id="L2728">							}, listData.isTransient());</span>

						}
<span class="fc" id="L2731">						displayResult();</span>
<span class="pc" id="L2732">					} catch (Throwable t) {</span>
<span class="nc" id="L2733">						swingRenderer.handleException(ListControl.this, t);</span>
					}
<span class="fc" id="L2735">				}</span>
			});
<span class="fc" id="L2737">		}</span>

		protected void displayResult() {
<span class="fc" id="L2740">		}</span>

	};

	protected class ItemUIBuilder extends AbstractEditorBuilder {
		protected BufferedItemPosition bufferedItemPosition;
		protected ListModificationFactory modificationFactory;
		protected boolean canCommit;
		protected ValueReturnMode objectValueReturnMode;

<span class="fc" id="L2750">		public ItemUIBuilder(BufferedItemPosition bufferedItemPosition) {</span>
<span class="fc" id="L2751">			setPosition(bufferedItemPosition);</span>
<span class="fc" id="L2752">		}</span>

		@Override
		protected IValidationJob getValueAbstractFormValidationJob() {
<span class="fc" id="L2756">			return bufferedItemPosition.getContainingListType()</span>
<span class="fc" id="L2757">					.getListItemAbstractFormValidationJob(bufferedItemPosition);</span>
		}

		public void setPosition(BufferedItemPosition bufferedItemPosition) {
<span class="fc" id="L2761">			this.bufferedItemPosition = bufferedItemPosition;</span>
<span class="fc" id="L2762">			this.modificationFactory = createListModificationFactory(bufferedItemPosition);</span>
<span class="fc" id="L2763">			this.canCommit = modificationFactory.canSet(bufferedItemPosition.getIndex());</span>
<span class="fc" id="L2764">			this.objectValueReturnMode = bufferedItemPosition.getItemReturnMode();</span>
<span class="fc" id="L2765">		}</span>

		@Override
		public Form createEditorForm(boolean realTimeLinkWithParent, boolean exclusiveLinkWithParent) {
<span class="fc" id="L2769">			Form result = super.createEditorForm(realTimeLinkWithParent, exclusiveLinkWithParent);</span>
<span class="fc" id="L2770">			postCopyValidationErrorFromCapsuleToItem(result);</span>
<span class="fc" id="L2771">			return result;</span>
		}

		protected void postCopyValidationErrorFromCapsuleToItem(Form form) {
<span class="fc" id="L2775">			form.getListeners().add(new Form.IFormListener() {</span>
				@Override
				public void onRefresh(boolean refreshStructure) {
<span class="fc" id="L2778">				}</span>

				@Override
				public void afterValidation(Exception validationError) {
<span class="fc" id="L2782">					itemValidationErrorsCollectingExecutor.submit(new Runnable() {</span>
						@Override
						public void run() {
<span class="fc" id="L2785">							copyValidationErrorFromCapsuleToItem(form.getObject());</span>
<span class="fc" id="L2786">						}</span>
					});
<span class="fc" id="L2788">				}</span>
			});
<span class="fc" id="L2790">		}</span>

		/**
		 * Allows to associate the current item with the eventual validation error of
		 * the capsule object, in order to anticipate the item validation error.
		 * 
		 * @param capsule The capsule object.
		 */
		protected void copyValidationErrorFromCapsuleToItem(Object capsule) {
<span class="fc bfc" id="L2799" title="All 2 branches covered.">			if (bufferedItemPosition.getContainingListType()</span>
<span class="fc" id="L2800">					.getListItemAbstractFormValidationJob(bufferedItemPosition) != null) {</span>
				/*
				 * Do not copy the eventual abstract form validation error because it may be
				 * structurally different (even if it represents the same incoherence) from the
				 * error that would have been generated from a concrete form. This ensures a
				 * uniform display of validation errors.
				 */
<span class="fc" id="L2807">				return;</span>
			}
<span class="fc" id="L2809">			Exception validitionError = swingRenderer.getReflectionUI().getValidationErrorRegistry()</span>
<span class="fc" id="L2810">					.getValidationError(capsule, null);</span>
<span class="fc bfc" id="L2811" title="All 2 branches covered.">			if (validitionError != null) {</span>
<span class="fc" id="L2812">				swingRenderer.getReflectionUI().getValidationErrorRegistry().attribute(bufferedItemPosition.getItem(),</span>
<span class="fc" id="L2813">						validitionError, null);</span>
<span class="fc" id="L2814">			} else {</span>
<span class="fc" id="L2815">				swingRenderer.getReflectionUI().getValidationErrorRegistry()</span>
<span class="fc" id="L2816">						.cancelAttribution(bufferedItemPosition.getItem(), null);</span>
			}
<span class="fc" id="L2818">		}</span>

		/**
		 * Allows to associate the eventual validation error (probably computed in
		 * background) of the current item with the capsule object, in order to
		 * anticipate the capsule validation error.
		 * 
		 * @param capsule The capsule object.
		 */
		protected void copyValidationErrorFromItemToCapsule(Object capsule) {
<span class="fc bfc" id="L2828" title="All 2 branches covered.">			if (bufferedItemPosition.getContainingListType()</span>
<span class="fc" id="L2829">					.getListItemAbstractFormValidationJob(bufferedItemPosition) != null) {</span>
				/*
				 * Do not copy the eventual abstract form validation error because it may be
				 * structurally different (even if it represents the same incoherence) from the
				 * error that would have been generated from a concrete form. This ensures a
				 * uniform display of validation errors.
				 */
<span class="fc" id="L2836">				return;</span>
			}
<span class="fc" id="L2838">			Exception itemValiditionError = swingRenderer.getReflectionUI().getValidationErrorRegistry()</span>
<span class="fc" id="L2839">					.getValidationError(bufferedItemPosition.getItem(), null);</span>
<span class="fc bfc" id="L2840" title="All 2 branches covered.">			if (itemValiditionError != null) {</span>
<span class="fc" id="L2841">				swingRenderer.getReflectionUI().getValidationErrorRegistry().attribute(capsule, itemValiditionError,</span>
<span class="fc" id="L2842">						null);</span>
<span class="fc" id="L2843">			} else {</span>
<span class="fc" id="L2844">				swingRenderer.getReflectionUI().getValidationErrorRegistry().cancelAttribution(capsule, null);</span>
			}
<span class="fc" id="L2846">		}</span>

		@Override
		public Object getNewCapsule() {
<span class="fc" id="L2850">			Object capsule = super.getNewCapsule();</span>
<span class="fc" id="L2851">			copyValidationErrorFromItemToCapsule(capsule);</span>
<span class="fc" id="L2852">			return capsule;</span>
		}

		@Override
		public void reloadValue(Form editorForm, boolean refreshStructure) {
<span class="fc" id="L2857">			Object capsule = editorForm.getObject();</span>
<span class="fc" id="L2858">			copyValidationErrorFromItemToCapsule(capsule);</span>
<span class="fc" id="L2859">			super.reloadValue(editorForm, refreshStructure);</span>
<span class="fc" id="L2860">		}</span>

		@Override
		protected IContext getContext() {
<span class="fc" id="L2864">			return input.getContext();</span>
		}

		@Override
		protected IContext getSubContext() {
<span class="fc" id="L2869">			return new CustomContext(&quot;ListItem&quot;);</span>
		}

		@Override
		protected boolean isEncapsulatedFormEmbedded() {
<span class="fc" id="L2874">			return true;</span>
		}

		@Override
		protected boolean isEncapsulatedisControlValueValiditionEnabled() {
<span class="fc" id="L2879">			return true;</span>
		}

		@Override
		protected boolean isNullValueDistinct() {
<span class="fc" id="L2884">			return bufferedItemPosition.getContainingListType().isItemNullValueSupported();</span>
		}

		@Override
		protected boolean canCommitToParent() {
<span class="fc" id="L2889">			return canCommit;</span>
		}

		@Override
		protected IModification createCommittingModification(final Object newItem) {
<span class="fc" id="L2894">			final Object oldItem = bufferedItemPosition.getItem();</span>
<span class="fc" id="L2895">			final List&lt;Object&gt; itemAncestors = ReflectionUIUtils.collectItemAncestors(bufferedItemPosition);</span>
<span class="fc" id="L2896">			IModification structureRefreshing = new RefreshModification(new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>

				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="fc" id="L2900">					return ReflectionUIUtils.actualizeItemPositions(Collections.singletonList(bufferedItemPosition),</span>
<span class="fc" id="L2901">							Collections.singletonList(newItem), Collections.singletonList(itemAncestors));</span>
				}
<span class="fc" id="L2903">			}, new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>

				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="nc" id="L2907">					return ReflectionUIUtils.actualizeItemPositions(Collections.singletonList(bufferedItemPosition),</span>
<span class="nc" id="L2908">							Collections.singletonList(oldItem), Collections.singletonList(itemAncestors));</span>
				}
			});
<span class="fc" id="L2911">			IModification update = modificationFactory.set(bufferedItemPosition.getIndex(), newItem);</span>
<span class="fc" id="L2912">			return ModificationStack.createCompositeModification(update.getTitle(), UndoOrder.FIFO, update,</span>
<span class="fc" id="L2913">					structureRefreshing);</span>
		}

		@Override
		protected IModification createUndoModificationsReplacement() {
<span class="fc" id="L2918">			return ReflectionUIUtils.createUndoModificationsReplacement(listData);</span>
		}

		@Override
		protected void handleRealtimeLinkCommitException(Throwable t) {
<span class="nc" id="L2923">			swingRenderer.handleException(ListControl.this, t);</span>
<span class="nc" id="L2924">		}</span>

		@Override
		public SwingRenderer getSwingRenderer() {
<span class="fc" id="L2928">			return swingRenderer;</span>
		}

		@Override
		protected String getParentModificationTitle() {
<span class="fc" id="L2933">			return getItemModificationTitle();</span>
		}

		@Override
		protected boolean isParentModificationVolatile() {
<span class="fc" id="L2938">			return listData.isTransient();</span>
		}

		@Override
		protected ITypeInfoSource getEncapsulatedFieldDeclaredTypeSource() {
<span class="fc" id="L2943">			ITypeInfo itemType = bufferedItemPosition.getContainingListType().getItemType();</span>
<span class="pc bpc" id="L2944" title="1 of 2 branches missed.">			if (itemType != null) {</span>
<span class="fc" id="L2945">				return itemType.getSource();</span>
			}
<span class="nc" id="L2947">			return new JavaTypeInfoSource(Object.class, null);</span>
		}

		@Override
		protected ValueReturnMode getReturnModeFromParent() {
<span class="fc" id="L2952">			return objectValueReturnMode;</span>
		}

		@Override
		protected Object loadValue() {
<span class="fc" id="L2957">			return bufferedItemPosition.getItem();</span>
		}

		@Override
		protected ModificationStack getParentModificationStack() {
<span class="fc" id="L2962">			return ListControl.this.getModificationStack();</span>
		}

		@Override
		protected Component getOwnerComponent() {
<span class="fc" id="L2967">			return ListControl.this;</span>
		}

		@Override
		protected IInfoFilter getEncapsulatedFormFilter() {
<span class="fc" id="L2972">			return getStructuralInfo(bufferedItemPosition).getItemDetailsInfoFilter(bufferedItemPosition);</span>
		}

		@Override
		protected boolean isValueKnownAsImmutable() {
<span class="fc" id="L2977">			return false;</span>
		}

	}

	protected class AnticipatedItemDialogBuilder extends ItemUIBuilder {
<span class="fc" id="L2983">		protected ModificationStack dummyModificationStack = new ModificationStack(null);</span>

<span class="fc" id="L2985">		public AnticipatedItemDialogBuilder(BufferedItemPosition bufferedItemPosition, Object item) {</span>
<span class="fc" id="L2986">			super(bufferedItemPosition);</span>
<span class="fc" id="L2987">			BufferedItemPosition fakeItemPosition = bufferedItemPosition.getSibling(-1);</span>
<span class="fc" id="L2988">			fakeItemPosition = (BufferedItemPosition) fakeItemPosition.clone();</span>
<span class="fc" id="L2989">			fakeItemPosition.setFakeItem(item);</span>
<span class="fc" id="L2990">			setPosition(fakeItemPosition);</span>
<span class="fc" id="L2991">		}</span>

		@Override
		protected ModificationStack getParentModificationStack() {
<span class="fc" id="L2995">			return dummyModificationStack;</span>
		}

		@Override
		protected boolean canCommitToParent() {
<span class="fc" id="L3000">			return true;</span>
		}

		@Override
		protected IModification createCommittingModification(Object newObjectValue) {
<span class="fc" id="L3005">			return IModification.NULL_MODIFICATION;</span>
		}

		@Override
		protected boolean isDialogCancellable() {
<span class="fc" id="L3010">			return true;</span>
		}
	}

	public interface IItemsVisitor {

		VisitStatus visitItem(BufferedItemPosition itemPosition);

<span class="fc" id="L3018">		public enum VisitStatus {</span>
<span class="fc" id="L3019">			VISIT_NOT_INTERRUPTED, SUBTREE_VISIT_INTERRUPTED, TREE_VISIT_INTERRUPTED</span>
		}

	}

<span class="fc" id="L3024">	protected enum InsertPosition {</span>
<span class="fc" id="L3025">		AFTER, BEFORE, UNKNOWN</span>
	}

<span class="fc" id="L3028">	protected class AddChildAction extends AbstractStandardListAction {</span>

		private static final long serialVersionUID = 1L;

		protected BufferedItemPosition newSubItemPosition;
		protected Object newSubListItem;
		protected IListTypeInfo subListType;

		@Override
		protected boolean prepare() {
<span class="fc" id="L3038">			newSubItemPosition = getNewSubItemPosition();</span>
<span class="fc" id="L3039">			subListType = newSubItemPosition.getContainingListType();</span>
<span class="fc" id="L3040">			ItemCreationMode itemCreationMode = subListType.getItemCreationMode();</span>
<span class="fc bfc" id="L3041" title="All 2 branches covered.">			if (itemCreationMode == ItemCreationMode.UNDEFINED) {</span>
<span class="fc" id="L3042">				itemCreationMode = getRelevantItemCreationMode(newSubItemPosition);</span>
			}
<span class="pc bpc" id="L3044" title="1 of 2 branches missed.">			if ((itemCreationMode == ItemCreationMode.UNVERIFIED_NULL)</span>
<span class="pc bpc" id="L3045" title="1 of 2 branches missed.">					|| (itemCreationMode == ItemCreationMode.VERIFIED_NULL)) {</span>
<span class="nc" id="L3046">				newSubListItem = null;</span>
<span class="pc bfc" id="L3047" title="All 2 branches covered.">			} else if ((itemCreationMode == ItemCreationMode.DEFAULT_UNVERIFIED_INSTANCE)</span>
<span class="fc bfc" id="L3048" title="All 2 branches covered.">					|| (itemCreationMode == ItemCreationMode.DEFAULT_VERIFIED_INSTANCE)) {</span>
<span class="fc" id="L3049">				newSubListItem = onItemCreationRequest(newSubItemPosition, false);</span>
<span class="pc bpc" id="L3050" title="1 of 2 branches missed.">			} else if ((itemCreationMode == ItemCreationMode.CUSTOM_UNVERIFIED_INSTANCE)</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">					|| (itemCreationMode == ItemCreationMode.CUSTOM_VERIFIED_INSTANCE)) {</span>
<span class="fc" id="L3052">				boolean nullValueChosen = false;</span>
<span class="pc bpc" id="L3053" title="1 of 2 branches missed.">				if (subListType.isItemNullValueSupported()) {</span>
<span class="nc" id="L3054">					String choice = swingRenderer.openSelectionDialog(ListControl.this,</span>
<span class="nc" id="L3055">							Arrays.asList(&quot;Create&quot;, &quot;&lt;Null&gt;&quot;), &quot;Create&quot;, &quot;Choose&quot;, getItemTitle(newSubItemPosition));</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">					if (choice == null) {</span>
<span class="nc" id="L3057">						return false;</span>
					}
<span class="nc bnc" id="L3059" title="All 2 branches missed.">					if (&quot;&lt;Null&gt;&quot;.equals(choice)) {</span>
<span class="nc" id="L3060">						newSubListItem = null;</span>
<span class="nc" id="L3061">						nullValueChosen = true;</span>
					}
				}
<span class="pc bpc" id="L3064" title="1 of 2 branches missed.">				if (!nullValueChosen) {</span>
<span class="fc" id="L3065">					newSubListItem = onItemCreationRequest(newSubItemPosition, true);</span>
<span class="pc bpc" id="L3066" title="1 of 2 branches missed.">					if (newSubListItem == null) {</span>
<span class="nc" id="L3067">						return false;</span>
					}
				}
			} else {
<span class="nc" id="L3071">				throw new ReflectionUIError();</span>
			}
<span class="pc bpc" id="L3073" title="1 of 2 branches missed.">			if ((itemCreationMode == ItemCreationMode.VERIFIED_NULL)</span>
<span class="fc bfc" id="L3074" title="All 2 branches covered.">					|| (itemCreationMode == ItemCreationMode.DEFAULT_VERIFIED_INSTANCE)</span>
<span class="pc bpc" id="L3075" title="1 of 2 branches missed.">					|| (itemCreationMode == ItemCreationMode.CUSTOM_VERIFIED_INSTANCE)) {</span>
<span class="fc" id="L3076">				ItemUIBuilder dialogBuilder = openAnticipatedItemDialog(newSubItemPosition, newSubListItem);</span>
<span class="pc bpc" id="L3077" title="1 of 2 branches missed.">				if (dialogBuilder.isCancelled()) {</span>
<span class="nc" id="L3078">					return false;</span>
				}
<span class="fc" id="L3080">				newSubListItem = dialogBuilder.getCurrentValue();</span>
			}
<span class="fc" id="L3082">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="fc" id="L3087">			final List&lt;Object&gt; newSubListItemAncestors = ReflectionUIUtils.collectItemAncestors(newSubItemPosition);</span>
<span class="fc" id="L3088">			getModificationStack().apply(createListModificationFactory(newSubItemPosition)</span>
<span class="fc" id="L3089">					.add(newSubItemPosition.getIndex(), newSubListItem));</span>
<span class="fc" id="L3090">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="fc" id="L3093">					return ReflectionUIUtils.actualizeItemPositions(Collections.singletonList(newSubItemPosition),</span>
<span class="fc" id="L3094">							Collections.singletonList(newSubListItem),</span>
<span class="fc" id="L3095">							Collections.singletonList(newSubListItemAncestors));</span>
				}
			};
<span class="fc" id="L3098">		}</span>

		@Override
		protected boolean isValid() {
<span class="fc" id="L3102">			BufferedItemPosition newSubItemPosition = getNewSubItemPosition();</span>
<span class="fc bfc" id="L3103" title="All 2 branches covered.">			if (newSubItemPosition == null) {</span>
<span class="fc" id="L3104">				return false;</span>
			}
<span class="fc bfc" id="L3106" title="All 2 branches covered.">			if (!createListModificationFactory(newSubItemPosition).canAdd(newSubItemPosition.getIndex())) {</span>
<span class="fc" id="L3107">				return false;</span>
			}
<span class="fc bfc" id="L3109" title="All 2 branches covered.">			if (!newSubItemPosition.getContainingListType().isInsertionAllowed()) {</span>
<span class="fc" id="L3110">				return false;</span>
			}
<span class="fc" id="L3112">			return true;</span>
		}

		protected BufferedItemPosition getNewSubItemPosition() {
<span class="fc" id="L3116">			BufferedItemPosition result = null;</span>
<span class="fc" id="L3117">			BufferedItemPosition singleSelection = getSingleSelection();</span>
<span class="fc bfc" id="L3118" title="All 2 branches covered.">			if (singleSelection != null) {</span>
<span class="fc" id="L3119">				result = singleSelection.getSubItemPosition(-1);</span>
<span class="fc" id="L3120">			} else {</span>
<span class="pc bpc" id="L3121" title="1 of 2 branches missed.">				if (getSelection().size() == 0) {</span>
<span class="fc" id="L3122">					result = itemPositionFactory.getRootItemPosition(-1);</span>
				}
			}
<span class="fc bfc" id="L3125" title="All 2 branches covered.">			if (result != null) {</span>
<span class="fc" id="L3126">				result = result.getSibling(result.getContainingListSize());</span>
			}
<span class="fc" id="L3128">			return result;</span>
		}

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3133">			BufferedItemPosition subItemPosition = getNewSubItemPosition();</span>
<span class="fc" id="L3134">			final IListTypeInfo subListType = subItemPosition.getContainingListType();</span>
<span class="fc" id="L3135">			final ITypeInfo subListItemType = subListType.getItemType();</span>
<span class="fc" id="L3136">			String title = &quot;Add&quot;;</span>
<span class="fc bfc" id="L3137" title="All 2 branches covered.">			if (subItemPosition.getDepth() &gt; 0) {</span>
<span class="fc" id="L3138">				title += &quot; Child&quot;;</span>
			}
<span class="pc bpc" id="L3140" title="1 of 2 branches missed.">			if (subListItemType != null) {</span>
<span class="fc" id="L3141">				title += &quot; &quot; + getItemTitle(subItemPosition);</span>
			}
<span class="fc bfc" id="L3143" title="All 2 branches covered.">			if (wouldDialogBeDisplayedOnItemCreation(subItemPosition)) {</span>
<span class="fc" id="L3144">				title += &quot;...&quot;;</span>
			}
<span class="fc" id="L3146">			return title;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="fc bfc" id="L3151" title="All 2 branches covered.">			if (getRootListTitle().length() == 0) {</span>
<span class="fc" id="L3152">				return &quot;Add item&quot;;</span>
			}
<span class="fc" id="L3154">			return &quot;Add item into '&quot; + getRootListTitle() + &quot;'&quot;;</span>
		}

	}

<span class="fc" id="L3159">	protected class ClearAction extends AbstractStandardListAction {</span>
		protected static final long serialVersionUID = 1L;

		@Override
		protected boolean prepare() {
<span class="pc bpc" id="L3164" title="1 of 2 branches missed.">			if (!userConfirms(&quot;Remove all the items?&quot;)) {</span>
<span class="nc" id="L3165">				return false;</span>
			}
<span class="fc" id="L3167">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="fc" id="L3172">			getModificationStack()</span>
<span class="fc" id="L3173">					.apply(createListModificationFactory(itemPositionFactory.getRootItemPosition(-1)).clear());</span>
<span class="fc" id="L3174">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="fc" id="L3177">					return Collections.emptyList();</span>
				}
			};
<span class="fc" id="L3180">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3184">			return &quot;Remove All&quot;;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="fc" id="L3189">			return &quot;Clear '&quot; + getRootListTitle() + &quot;'&quot;;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc bfc" id="L3194" title="All 2 branches covered.">			if (getRootListRawValue().length &gt; 0) {</span>
<span class="fc bfc" id="L3195" title="All 2 branches covered.">				if (createListModificationFactory(itemPositionFactory.getRootItemPosition(-1)).canClear()) {</span>
<span class="pc bpc" id="L3196" title="1 of 2 branches missed.">					if (getRootListType().isRemovalAllowed()) {</span>
<span class="fc" id="L3197">						return true;</span>
					}
				}
			}
<span class="fc" id="L3201">			return false;</span>
		}
	}

<span class="fc" id="L3205">	protected class CopyAction extends AbstractStandardListAction {</span>
		protected static final long serialVersionUID = 1L;

		@Override
		protected boolean prepare() {
<span class="nc" id="L3210">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="nc" id="L3215">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="nc" id="L3216">			clipboard.clear();</span>
<span class="nc bnc" id="L3217" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3218">				clipboard.add(ReflectionUIUtils.copy(swingRenderer.getReflectionUI(), itemPosition.getItem()));</span>
			}
<span class="nc" id="L3220">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3224">			return &quot;Copy&quot;;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="nc" id="L3229">			return null;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc" id="L3234">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="fc bfc" id="L3235" title="All 2 branches covered.">			if (selection.size() &gt; 0) {</span>
<span class="fc bfc" id="L3236" title="All 2 branches covered.">				if (canCopyAll(selection)) {</span>
<span class="fc" id="L3237">					return true;</span>
				}
			}
<span class="fc" id="L3240">			return false;</span>
		}

	}

<span class="fc" id="L3245">	protected class CutAction extends AbstractStandardListAction {</span>

		protected static final long serialVersionUID = 1L;

		@Override
		protected boolean prepare() {
<span class="nc" id="L3251">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="nc" id="L3256">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="nc" id="L3257">			List&lt;BufferedItemPosition&gt; postSelection = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="nc bnc" id="L3258" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3259">				itemPosition = getPositionSelectedByItemRemoval(itemPosition);</span>
<span class="nc bnc" id="L3260" title="All 2 branches missed.">				if (itemPosition != null) {</span>
<span class="nc" id="L3261">					postSelection.add(itemPosition);</span>
				}
			}
<span class="nc bnc" id="L3264" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3265">				purgePositionsAfterItemRemoval(postSelection, itemPosition);</span>
			}
<span class="nc" id="L3267">			List&lt;Object&gt; postSelectionItems = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L3268">			List&lt;List&lt;Object&gt;&gt; postSelectionItemAncestorLists = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : postSelection) {</span>
<span class="nc" id="L3270">				postSelectionItems.add(itemPosition.getItem());</span>
<span class="nc" id="L3271">				postSelectionItemAncestorLists.add(ReflectionUIUtils.collectItemAncestors(itemPosition));</span>
			}
<span class="nc bnc" id="L3273" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3274">				shiftPositionsAfterItemRemoval(postSelection, itemPosition);</span>
			}
<span class="nc" id="L3276">			selection = new ArrayList&lt;BufferedItemPosition&gt;(selection);</span>
<span class="nc" id="L3277">			Collections.sort(selection);</span>
<span class="nc" id="L3278">			Collections.reverse(selection);</span>
<span class="nc" id="L3279">			clipboard.clear();</span>
<span class="nc bnc" id="L3280" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3281">				clipboard.add(0, ReflectionUIUtils.copy(swingRenderer.getReflectionUI(), itemPosition.getItem()));</span>
<span class="nc" id="L3282">				getModificationStack()</span>
<span class="nc" id="L3283">						.apply(createListModificationFactory(itemPosition).remove(itemPosition.getIndex()));</span>
			}
<span class="nc" id="L3285">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="nc" id="L3288">					return ReflectionUIUtils.actualizeItemPositions(postSelection, postSelectionItems,</span>
<span class="nc" id="L3289">							postSelectionItemAncestorLists);</span>
				}
			};
<span class="nc" id="L3292">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3296">			return &quot;Cut&quot;;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="nc bnc" id="L3301" title="All 2 branches missed.">			if (getRootListTitle().length() == 0) {</span>
<span class="nc" id="L3302">				return &quot;Cut item(s)&quot;;</span>
			}
<span class="nc" id="L3304">			return &quot;Cut '&quot; + getRootListTitle() + &quot;' item(s)&quot;;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc" id="L3309">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="fc bfc" id="L3310" title="All 2 branches covered.">			if (selection.size() &gt; 0) {</span>
<span class="pc bpc" id="L3311" title="1 of 4 branches missed.">				if (canCopyAll(selection) &amp;&amp; canRemoveAll(selection)) {</span>
<span class="fc bfc" id="L3312" title="All 2 branches covered.">					for (BufferedItemPosition itemPosition1 : selection) {</span>
<span class="fc bfc" id="L3313" title="All 2 branches covered.">						for (BufferedItemPosition itemPosition2 : new ArrayList&lt;BufferedItemPosition&gt;(selection)) {</span>
<span class="pc bpc" id="L3314" title="1 of 2 branches missed.">							if (itemPosition1.getAncestors().contains(itemPosition2)) {</span>
<span class="nc" id="L3315">								return false;</span>
							}
						}
					}
<span class="fc" id="L3319">					return true;</span>
				}
			}
<span class="fc" id="L3322">			return false;</span>
		}

	}

	protected class InsertAction extends AbstractStandardListAction {
		protected static final long serialVersionUID = 1L;

		protected InsertPosition insertPosition;

		protected BufferedItemPosition newItemPosition;
		protected Object newItem;
		protected IListTypeInfo listType;

<span class="fc" id="L3336">		public InsertAction(InsertPosition insertPosition) {</span>
<span class="fc" id="L3337">			this.insertPosition = insertPosition;</span>
<span class="fc" id="L3338">		}</span>

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="fc" id="L3342">			final List&lt;Object&gt; newItemAncestors = ReflectionUIUtils.collectItemAncestors(newItemPosition);</span>
<span class="fc" id="L3343">			getModificationStack()</span>
<span class="fc" id="L3344">					.apply(createListModificationFactory(newItemPosition).add(newItemPosition.getIndex(), newItem));</span>
<span class="fc" id="L3345">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="fc" id="L3348">					return ReflectionUIUtils.actualizeItemPositions(Collections.singletonList(newItemPosition),</span>
<span class="fc" id="L3349">							Collections.singletonList(newItem), Collections.singletonList(newItemAncestors));</span>
				}
			};
<span class="fc" id="L3352">		}</span>

		@Override
		protected boolean prepare() {
<span class="fc" id="L3356">			newItemPosition = getNewItemPosition();</span>
<span class="fc" id="L3357">			listType = newItemPosition.getContainingListType();</span>
<span class="fc" id="L3358">			ItemCreationMode itemCreationMode = listType.getItemCreationMode();</span>
<span class="pc bpc" id="L3359" title="1 of 2 branches missed.">			if (itemCreationMode == ItemCreationMode.UNDEFINED) {</span>
<span class="fc" id="L3360">				itemCreationMode = getRelevantItemCreationMode(newItemPosition);</span>
			}
<span class="pc bpc" id="L3362" title="1 of 2 branches missed.">			if ((itemCreationMode == ItemCreationMode.UNVERIFIED_NULL)</span>
<span class="pc bpc" id="L3363" title="1 of 2 branches missed.">					|| (itemCreationMode == ItemCreationMode.VERIFIED_NULL)) {</span>
<span class="nc" id="L3364">				newItem = null;</span>
<span class="pc bpc" id="L3365" title="1 of 2 branches missed.">			} else if ((itemCreationMode == ItemCreationMode.DEFAULT_UNVERIFIED_INSTANCE)</span>
<span class="fc bfc" id="L3366" title="All 2 branches covered.">					|| (itemCreationMode == ItemCreationMode.DEFAULT_VERIFIED_INSTANCE)) {</span>
<span class="fc" id="L3367">				newItem = onItemCreationRequest(newItemPosition, false);</span>
<span class="pc bpc" id="L3368" title="1 of 2 branches missed.">			} else if ((itemCreationMode == ItemCreationMode.CUSTOM_UNVERIFIED_INSTANCE)</span>
<span class="nc bnc" id="L3369" title="All 2 branches missed.">					|| (itemCreationMode == ItemCreationMode.CUSTOM_VERIFIED_INSTANCE)) {</span>
<span class="fc" id="L3370">				boolean nullValueChosen = false;</span>
<span class="pc bpc" id="L3371" title="1 of 2 branches missed.">				if (listType.isItemNullValueSupported()) {</span>
<span class="nc" id="L3372">					String choice = swingRenderer.openSelectionDialog(ListControl.this,</span>
<span class="nc" id="L3373">							Arrays.asList(&quot;Create&quot;, &quot;&lt;Null&gt;&quot;), &quot;Create&quot;, &quot;Choose&quot;, getItemTitle(newItemPosition));</span>
<span class="nc bnc" id="L3374" title="All 2 branches missed.">					if (choice == null) {</span>
<span class="nc" id="L3375">						return false;</span>
					}
<span class="nc bnc" id="L3377" title="All 2 branches missed.">					if (&quot;&lt;Null&gt;&quot;.equals(choice)) {</span>
<span class="nc" id="L3378">						newItem = null;</span>
<span class="nc" id="L3379">						nullValueChosen = true;</span>
					}
				}
<span class="pc bpc" id="L3382" title="1 of 2 branches missed.">				if (!nullValueChosen) {</span>
<span class="fc" id="L3383">					newItem = onItemCreationRequest(newItemPosition, true);</span>
<span class="pc bpc" id="L3384" title="1 of 2 branches missed.">					if (newItem == null) {</span>
<span class="nc" id="L3385">						return false;</span>
					}
				}
			} else {
<span class="nc" id="L3389">				throw new ReflectionUIError();</span>
			}
<span class="pc bpc" id="L3391" title="1 of 2 branches missed.">			if ((itemCreationMode == ItemCreationMode.VERIFIED_NULL)</span>
<span class="fc bfc" id="L3392" title="All 2 branches covered.">					|| (itemCreationMode == ItemCreationMode.DEFAULT_VERIFIED_INSTANCE)</span>
<span class="pc bpc" id="L3393" title="1 of 2 branches missed.">					|| (itemCreationMode == ItemCreationMode.CUSTOM_VERIFIED_INSTANCE)) {</span>
<span class="fc" id="L3394">				ItemUIBuilder dialogBuilder = openAnticipatedItemDialog(newItemPosition, newItem);</span>
<span class="pc bpc" id="L3395" title="1 of 2 branches missed.">				if (dialogBuilder.isCancelled()) {</span>
<span class="nc" id="L3396">					return false;</span>
				}
<span class="fc" id="L3398">				newItem = dialogBuilder.getCurrentValue();</span>
			}
<span class="fc" id="L3400">			return true;</span>
		}

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3405">			BufferedItemPosition newItemPosition = getNewItemPosition();</span>
<span class="pc bpc" id="L3406" title="1 of 2 branches missed.">			if (newItemPosition == null) {</span>
<span class="nc" id="L3407">				return null;</span>
			}
<span class="fc" id="L3409">			IListTypeInfo listType = newItemPosition.getContainingListType();</span>
<span class="fc" id="L3410">			ITypeInfo itemType = listType.getItemType();</span>

<span class="fc" id="L3412">			String buttonText = &quot;Insert&quot;;</span>
			{
<span class="pc bpc" id="L3414" title="1 of 2 branches missed.">				if (itemType != null) {</span>
<span class="fc" id="L3415">					buttonText += &quot; &quot; + getItemTitle(newItemPosition);</span>
				}
<span class="fc bfc" id="L3417" title="All 2 branches covered.">				if (insertPosition == InsertPosition.AFTER) {</span>
<span class="fc" id="L3418">					buttonText += &quot; After&quot;;</span>
<span class="pc bpc" id="L3419" title="1 of 2 branches missed.">				} else if (insertPosition == InsertPosition.BEFORE) {</span>
<span class="fc" id="L3420">					buttonText += &quot; Before&quot;;</span>
				}
<span class="fc bfc" id="L3422" title="All 2 branches covered.">				if (wouldDialogBeDisplayedOnItemCreation(newItemPosition)</span>
<span class="pc bpc" id="L3423" title="1 of 2 branches missed.">						|| getDetailsAccessMode().hasDetachedDetailsDisplayOption()) {</span>
<span class="fc" id="L3424">					buttonText += &quot; ...&quot;;</span>
				}
			}
<span class="fc" id="L3427">			return buttonText;</span>
		}

		protected BufferedItemPosition getNewItemPosition() {
<span class="fc" id="L3431">			BufferedItemPosition singleSelection = getSingleSelection();</span>
			final int index;
<span class="fc bfc" id="L3433" title="All 2 branches covered.">			if (singleSelection == null) {</span>
<span class="fc" id="L3434">				return null;</span>
			} else {
<span class="fc bfc" id="L3436" title="All 2 branches covered.">				if (insertPosition == InsertPosition.AFTER) {</span>
<span class="fc" id="L3437">					index = singleSelection.getIndex();</span>
<span class="fc" id="L3438">					return singleSelection.getSibling(index + 1);</span>
				} else {
<span class="fc" id="L3440">					return singleSelection;</span>
				}

			}
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="fc" id="L3448">			return &quot;Insert into '&quot; + getRootListTitle() + &quot;'&quot;;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc" id="L3453">			BufferedItemPosition newItemPosition = getNewItemPosition();</span>
<span class="fc bfc" id="L3454" title="All 2 branches covered.">			if (newItemPosition != null) {</span>
<span class="fc bfc" id="L3455" title="All 2 branches covered.">				if (newItemPosition.getContainingListType().isInsertionAllowed()) {</span>
<span class="fc bfc" id="L3456" title="All 2 branches covered.">					if (createListModificationFactory(newItemPosition).canAdd(newItemPosition.getIndex())) {</span>
<span class="fc bfc" id="L3457" title="All 2 branches covered.">						if (insertPosition == InsertPosition.BEFORE) {</span>
<span class="pc bpc" id="L3458" title="1 of 2 branches missed.">							if (!newItemPosition.getContainingListType().areItemsAutomaticallyPositioned()) {</span>
<span class="fc" id="L3459">								return true;</span>
							}
						}
<span class="fc bfc" id="L3462" title="All 2 branches covered.">						if (insertPosition == InsertPosition.AFTER) {</span>
<span class="pc bpc" id="L3463" title="1 of 2 branches missed.">							if (!newItemPosition.getContainingListType().areItemsAutomaticallyPositioned()) {</span>
<span class="fc" id="L3464">								return true;</span>
							}
						}
<span class="pc bpc" id="L3467" title="1 of 2 branches missed.">						if (insertPosition == InsertPosition.UNKNOWN) {</span>
<span class="pc bpc" id="L3468" title="1 of 2 branches missed.">							if (newItemPosition.getContainingListType().areItemsAutomaticallyPositioned()) {</span>
<span class="nc" id="L3469">								return true;</span>
							}
						}
					}
				}
			}
<span class="fc" id="L3475">			return false;</span>
		}
	}

	protected class MoveAction extends AbstractStandardListAction {
		protected static final long serialVersionUID = 1L;
		protected int offset;

<span class="fc" id="L3483">		public MoveAction(int offset) {</span>
<span class="fc" id="L3484">			this.offset = offset;</span>
<span class="fc" id="L3485">		}</span>

		@Override
		protected boolean prepare() {
<span class="nc" id="L3489">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="nc" id="L3494">			avoidRestoringExpandedPathOfMovedNode();</span>
<span class="nc" id="L3495">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="nc bnc" id="L3496" title="All 2 branches missed.">			if (offset &gt; 0) {</span>
<span class="nc" id="L3497">				selection = new ArrayList&lt;BufferedItemPosition&gt;(selection);</span>
<span class="nc" id="L3498">				Collections.reverse(selection);</span>
			}
<span class="nc" id="L3500">			List&lt;BufferedItemPosition&gt; newSelection = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="nc" id="L3501">			List&lt;Object&gt; newSelectionItems = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L3502">			List&lt;List&lt;Object&gt;&gt; newSelectionItemAncestorLists = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
<span class="nc bnc" id="L3503" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3504">				int index = itemPosition.getIndex();</span>
<span class="nc" id="L3505">				getModificationStack().apply(createListModificationFactory(itemPosition).move(index, offset));</span>
<span class="nc" id="L3506">				newSelection.add(itemPosition.getSibling(index + offset));</span>
<span class="nc" id="L3507">				newSelectionItems.add(itemPosition.getSibling(index + offset).getItem());</span>
<span class="nc" id="L3508">				newSelectionItemAncestorLists</span>
<span class="nc" id="L3509">						.add(ReflectionUIUtils.collectItemAncestors(itemPosition.getSibling(index + offset)));</span>
			}
<span class="nc" id="L3511">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="nc" id="L3514">					return ReflectionUIUtils.actualizeItemPositions(newSelection, newSelectionItems,</span>
<span class="nc" id="L3515">							newSelectionItemAncestorLists);</span>
				}
			};
<span class="nc" id="L3518">		}</span>

		protected void avoidRestoringExpandedPathOfMovedNode() {
<span class="nc" id="L3521">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="nc" id="L3522">			BufferedItemPosition first = selection.get(0);</span>
<span class="nc bnc" id="L3523" title="All 2 branches missed.">			for (int i = 0; i &lt; first.getContainingListSize(); i++) {</span>
<span class="nc" id="L3524">				BufferedItemPosition itemPosition = first.getSibling(i);</span>
<span class="nc" id="L3525">				collapseItemPosition(itemPosition);</span>
			}
<span class="nc" id="L3527">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc bfc" id="L3531" title="All 2 branches covered.">			return (offset &gt; 0) ? &quot;Move Down&quot; : &quot;Move Up&quot;;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="nc bnc" id="L3536" title="All 2 branches missed.">			if (getRootListTitle().length() == 0) {</span>
<span class="nc" id="L3537">				return &quot;Move item(s)&quot;;</span>
			}
<span class="nc" id="L3539">			return &quot;Move '&quot; + getRootListTitle() + &quot;' item(s)&quot;;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc" id="L3544">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="fc bfc" id="L3545" title="All 2 branches covered.">			if (selection.size() &gt; 0) {</span>
<span class="fc bfc" id="L3546" title="All 2 branches covered.">				if (canMoveAll(selection, offset)) {</span>
<span class="pc bpc" id="L3547" title="1 of 2 branches missed.">					if (allSelectionItemsInSameList()) {</span>
<span class="fc" id="L3548">						return true;</span>
					}
				}
			}
<span class="fc" id="L3552">			return false;</span>
		}

	}

<span class="fc" id="L3557">	protected class OpenItemAction extends AbstractStandardListAction {</span>
		protected static final long serialVersionUID = 1L;

		protected ItemUIBuilder dialogBuilder;

		@Override
		protected boolean prepare() {
<span class="fc" id="L3564">			BufferedItemPosition itemPosition = getSingleSelection();</span>
<span class="pc bpc" id="L3565" title="1 of 2 branches missed.">			if (itemPosition != null) {</span>
<span class="fc" id="L3566">				ListControl masterListControl = getMasterListControl();</span>
<span class="pc bpc" id="L3567" title="1 of 2 branches missed.">				if (masterListControl != null) {</span>
<span class="nc" id="L3568">					masterListControl.setSingleSelection(toMasterListControlItemPosition(itemPosition));</span>
<span class="nc" id="L3569">					return true;</span>
				}
			}
<span class="fc" id="L3572">			dialogBuilder = createItemUIBuilder(itemPosition);</span>
<span class="fc" id="L3573">			JDialog dialog = dialogBuilder.createDialog();</span>
<span class="fc" id="L3574">			swingRenderer.showDialog(dialog, true);</span>
<span class="fc" id="L3575">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="fc" id="L3580">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3584">			return &quot;Open&quot;;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="fc" id="L3589">			return getItemModificationTitle();</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc bfc" id="L3594" title="All 2 branches covered.">			if (!getDetailsAccessMode().hasDetachedDetailsDisplayOption()) {</span>
<span class="fc" id="L3595">				return false;</span>
			}
<span class="fc" id="L3597">			BufferedItemPosition singleSelectedPosition = getSingleSelection();</span>
<span class="fc bfc" id="L3598" title="All 2 branches covered.">			if (singleSelectedPosition != null) {</span>
<span class="pc bpc" id="L3599" title="1 of 2 branches missed.">				if (!createItemUIBuilder(singleSelectedPosition).isFormEmpty()) {</span>
<span class="fc" id="L3600">					IListTypeInfo listType = singleSelectedPosition.getContainingListType();</span>
<span class="fc bfc" id="L3601" title="All 2 branches covered.">					if (listType.canViewItemDetails()) {</span>
<span class="fc" id="L3602">						return true;</span>
					}
				}
			}
<span class="fc" id="L3606">			return false;</span>
		}
	}

	protected class PasteAction extends InsertAction {

		protected static final long serialVersionUID = 1L;

<span class="fc" id="L3614">		public PasteAction(InsertPosition insertPosition) {</span>
<span class="fc" id="L3615">			super(insertPosition);</span>
<span class="fc" id="L3616">		}</span>

		@Override
		protected boolean prepare() {
<span class="nc" id="L3620">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="nc" id="L3625">			BufferedItemPosition newItemPosition = getNewItemPosition();</span>
<span class="nc" id="L3626">			int index = newItemPosition.getIndex();</span>
<span class="nc" id="L3627">			final List&lt;BufferedItemPosition&gt; postSelection = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="nc" id="L3628">			final List&lt;Object&gt; postSelectionItems = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L3629">			final List&lt;List&lt;Object&gt;&gt; postSelectionItemAncestors = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
<span class="nc bnc" id="L3630" title="All 2 branches missed.">			for (Object clipboardItem : clipboard) {</span>
<span class="nc" id="L3631">				Object clipboardItemCopy = ReflectionUIUtils.copy(swingRenderer.getReflectionUI(), clipboardItem);</span>
<span class="nc" id="L3632">				getModificationStack()</span>
<span class="nc" id="L3633">						.apply(createListModificationFactory(newItemPosition).add(index, clipboardItemCopy));</span>
<span class="nc" id="L3634">				postSelection.add(newItemPosition.getSibling(index));</span>
<span class="nc" id="L3635">				postSelectionItems.add(clipboardItemCopy);</span>
<span class="nc" id="L3636">				postSelectionItemAncestors</span>
<span class="nc" id="L3637">						.add(ReflectionUIUtils.collectItemAncestors(newItemPosition.getSibling(index)));</span>
<span class="nc" id="L3638">				index++;</span>
			}
<span class="nc" id="L3640">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="nc" id="L3643">					return ReflectionUIUtils.actualizeItemPositions(postSelection, postSelectionItems,</span>
<span class="nc" id="L3644">							postSelectionItemAncestors);</span>
				}
			};
<span class="nc" id="L3647">		}</span>

		@Override
		protected String getActionTitle() {
<span class="nc" id="L3651">			BufferedItemPosition newItemPosition = getNewItemPosition();</span>
<span class="nc bnc" id="L3652" title="All 2 branches missed.">			if (newItemPosition == null) {</span>
<span class="nc" id="L3653">				return null;</span>
			}
<span class="nc" id="L3655">			String buttonText = &quot;Paste&quot;;</span>
			{
<span class="nc bnc" id="L3657" title="All 2 branches missed.">				if (insertPosition == InsertPosition.AFTER) {</span>
<span class="nc" id="L3658">					buttonText += &quot; After&quot;;</span>
<span class="nc bnc" id="L3659" title="All 2 branches missed.">				} else if (insertPosition == InsertPosition.BEFORE) {</span>
<span class="nc" id="L3660">					buttonText += &quot; Before&quot;;</span>
				}
			}
<span class="nc" id="L3663">			return buttonText;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="nc" id="L3668">			return &quot;Paste into '&quot; + getRootListTitle() + &quot;'&quot;;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc bfc" id="L3673" title="All 2 branches covered.">			if (!super.isValid()) {</span>
<span class="fc" id="L3674">				return false;</span>
			}
<span class="pc bpc" id="L3676" title="1 of 2 branches missed.">			if (clipboard.size() == 0) {</span>
<span class="fc" id="L3677">				return false;</span>
			}
<span class="nc" id="L3679">			BufferedItemPosition newItemPosition = getNewItemPosition();</span>
<span class="nc bnc" id="L3680" title="All 2 branches missed.">			if (!createListModificationFactory(newItemPosition).canAddAll(newItemPosition.getIndex(), clipboard)) {</span>
<span class="nc" id="L3681">				return false;</span>
			}
<span class="nc" id="L3683">			return true;</span>
		}
	}

<span class="fc" id="L3687">	protected class PasteIntoAction extends AddChildAction {</span>

		protected static final long serialVersionUID = 1L;

		@Override
		protected boolean prepare() {
<span class="nc" id="L3693">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="nc" id="L3698">			BufferedItemPosition subItemPosition = getNewItemPosition();</span>
<span class="nc" id="L3699">			int newSubListItemIndex = subItemPosition.getContainingListSize();</span>
<span class="nc" id="L3700">			int newSubListItemInitialIndex = newSubListItemIndex;</span>
<span class="nc" id="L3701">			subItemPosition = subItemPosition.getSibling(newSubListItemIndex);</span>
<span class="nc" id="L3702">			final List&lt;BufferedItemPosition&gt; postSelection = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="nc" id="L3703">			final List&lt;Object&gt; postSelectionItems = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L3704">			final List&lt;List&lt;Object&gt;&gt; postSelectionItemAncestorLists = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
<span class="nc bnc" id="L3705" title="All 2 branches missed.">			for (Object clipboardItem : clipboard) {</span>
<span class="nc" id="L3706">				Object clipboardItemCopy = ReflectionUIUtils.copy(swingRenderer.getReflectionUI(), clipboardItem);</span>
<span class="nc" id="L3707">				getModificationStack().apply(</span>
<span class="nc" id="L3708">						createListModificationFactory(subItemPosition).add(newSubListItemIndex, clipboardItemCopy));</span>
<span class="nc" id="L3709">				postSelection.add(subItemPosition.getSibling(newSubListItemInitialIndex));</span>
<span class="nc" id="L3710">				postSelectionItems.add(clipboardItemCopy);</span>
<span class="nc" id="L3711">				postSelectionItemAncestorLists.add(</span>
<span class="nc" id="L3712">						ReflectionUIUtils.collectItemAncestors(subItemPosition.getSibling(newSubListItemInitialIndex)));</span>
<span class="nc" id="L3713">				newSubListItemIndex++;</span>
			}
<span class="nc" id="L3715">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="nc" id="L3718">					return ReflectionUIUtils.actualizeItemPositions(postSelection, postSelectionItems,</span>
<span class="nc" id="L3719">							postSelectionItemAncestorLists);</span>
				}
			};
<span class="nc" id="L3722">		}</span>

		protected BufferedItemPosition getNewItemPosition() {
<span class="nc" id="L3725">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="nc bnc" id="L3726" title="All 2 branches missed.">			if (selection.size() == 0) {</span>
<span class="nc" id="L3727">				return itemPositionFactory.getRootItemPosition(0);</span>
			}
<span class="nc bnc" id="L3729" title="All 2 branches missed.">			if (selection.size() == 1) {</span>
<span class="nc" id="L3730">				return selection.get(0).getSubItemPosition(0);</span>
			}
<span class="nc" id="L3732">			return null;</span>
		}

		@Override
		protected String getActionTitle() {
<span class="nc" id="L3737">			return &quot;Paste Into&quot;;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="nc bnc" id="L3742" title="All 2 branches missed.">			if (getRootListTitle().length() == 0) {</span>
<span class="nc" id="L3743">				return &quot;Paste item(s)&quot;;</span>
			}
<span class="nc" id="L3745">			return &quot;Paste item(s) into '&quot; + getRootListTitle() + &quot;'&quot;;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc bfc" id="L3750" title="All 2 branches covered.">			if (!super.isValid()) {</span>
<span class="fc" id="L3751">				return false;</span>
			}
<span class="pc bpc" id="L3753" title="1 of 2 branches missed.">			if (clipboard.size() == 0) {</span>
<span class="fc" id="L3754">				return false;</span>
			}
<span class="nc" id="L3756">			BufferedItemPosition newItemPosition = getNewItemPosition();</span>
<span class="nc bnc" id="L3757" title="All 2 branches missed.">			if (!createListModificationFactory(newItemPosition).canAddAll(newItemPosition.getIndex(), clipboard)) {</span>
<span class="nc" id="L3758">				return false;</span>
			}
<span class="nc" id="L3760">			return true;</span>

		}
	}

<span class="fc" id="L3765">	protected class RemoveAction extends AbstractStandardListAction {</span>
		protected static final long serialVersionUID = 1L;

		@Override
		protected boolean prepare() {
<span class="nc" id="L3770">			return userConfirms(&quot;Remove the element(s)?&quot;);</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="nc" id="L3775">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="nc" id="L3776">			List&lt;BufferedItemPosition&gt; postSelection = new ArrayList&lt;BufferedItemPosition&gt;();</span>
<span class="nc bnc" id="L3777" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3778">				itemPosition = getPositionSelectedByItemRemoval(itemPosition);</span>
<span class="nc bnc" id="L3779" title="All 2 branches missed.">				if (itemPosition != null) {</span>
<span class="nc" id="L3780">					postSelection.add(itemPosition);</span>
				}
			}
<span class="nc bnc" id="L3783" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3784">				purgePositionsAfterItemRemoval(postSelection, itemPosition);</span>
			}
<span class="nc" id="L3786">			List&lt;Object&gt; postSelectionItems = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L3787">			List&lt;List&lt;Object&gt;&gt; postSelectionItemAncestorLists = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>
<span class="nc bnc" id="L3788" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : postSelection) {</span>
<span class="nc" id="L3789">				postSelectionItems.add(itemPosition.getItem());</span>
<span class="nc" id="L3790">				postSelectionItemAncestorLists.add(ReflectionUIUtils.collectItemAncestors(itemPosition));</span>
			}
<span class="nc bnc" id="L3792" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3793">				shiftPositionsAfterItemRemoval(postSelection, itemPosition);</span>
			}
<span class="nc" id="L3795">			selection = new ArrayList&lt;BufferedItemPosition&gt;(selection);</span>
<span class="nc" id="L3796">			Collections.sort(selection);</span>
<span class="nc" id="L3797">			Collections.reverse(selection);</span>
<span class="nc bnc" id="L3798" title="All 2 branches missed.">			for (BufferedItemPosition itemPosition : selection) {</span>
<span class="nc" id="L3799">				getModificationStack()</span>
<span class="nc" id="L3800">						.apply(createListModificationFactory(itemPosition).remove(itemPosition.getIndex()));</span>
			}
<span class="nc" id="L3802">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="nc" id="L3805">					return ReflectionUIUtils.actualizeItemPositions(postSelection, postSelectionItems,</span>
<span class="nc" id="L3806">							postSelectionItemAncestorLists);</span>
				}
			};
<span class="nc" id="L3809">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3813">			return &quot;Remove&quot;;</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="nc bnc" id="L3818" title="All 2 branches missed.">			if (getRootListTitle().length() == 0) {</span>
<span class="nc" id="L3819">				return &quot;Remove item(s)&quot;;</span>
			}
<span class="nc" id="L3821">			return &quot;Remove '&quot; + getRootListTitle() + &quot;' item(s)&quot;;</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc" id="L3826">			List&lt;BufferedItemPosition&gt; selection = getSelection();</span>
<span class="fc bfc" id="L3827" title="All 2 branches covered.">			if (selection.size() == 0) {</span>
<span class="fc" id="L3828">				return false;</span>
			}
<span class="pc bpc" id="L3830" title="1 of 2 branches missed.">			if (selection.size() &gt; 0) {</span>
<span class="fc bfc" id="L3831" title="All 2 branches covered.">				for (BufferedItemPosition selectionItem : selection) {</span>
<span class="fc bfc" id="L3832" title="All 2 branches covered.">					if (!createListModificationFactory(selectionItem).canRemove(selectionItem.getIndex())) {</span>
<span class="fc" id="L3833">						return false;</span>
					}
<span class="fc bfc" id="L3835" title="All 2 branches covered.">					if (!selectionItem.getContainingListType().isRemovalAllowed()) {</span>
<span class="fc" id="L3836">						return false;</span>
					}
				}
			}
<span class="fc" id="L3840">			return true;</span>
		}
	}

	protected class DynamicActionHook extends AbstractStandardListAction {
		protected static final long serialVersionUID = 1L;

		protected IDynamicListAction dynamicAction;
		protected MethodAction action;
		protected InvocationData invocationData;

<span class="fc" id="L3851">		public DynamicActionHook(IDynamicListAction dynamicAction) {</span>
<span class="fc" id="L3852">			this.dynamicAction = dynamicAction;</span>
<span class="fc" id="L3853">		}</span>

		@Override
		public Object getValue(String key) {
<span class="fc bfc" id="L3857" title="All 2 branches covered.">			if (Action.LARGE_ICON_KEY.equals(key)) {</span>
<span class="fc" id="L3858">				Image iconImage = swingRenderer.getMethodIconImage(new DefaultMethodControlData(</span>
<span class="fc" id="L3859">						swingRenderer.getReflectionUI(), IDynamicListAction.NO_OWNER, dynamicAction));</span>
<span class="pc bpc" id="L3860" title="1 of 2 branches missed.">				if (iconImage == null) {</span>
<span class="fc" id="L3861">					return null;</span>
				}
<span class="nc" id="L3863">				return SwingRendererUtils.getIcon(iconImage);</span>
			} else {
<span class="fc" id="L3865">				return super.getValue(key);</span>
			}
		}

		@Override
		protected boolean prepare() {
<span class="fc" id="L3871">			action = swingRenderer.createMethodAction(new IMethodControlInput() {</span>

				@Override
				public ModificationStack getModificationStack() {
<span class="fc" id="L3875">					return ListControl.this.getModificationStack();</span>
				}

				@Override
				public MethodContext getContext() {
<span class="fc" id="L3880">					return new MethodContext(null, dynamicAction.getSignature()) {</span>

						@Override
						public String getIdentifier() {
<span class="fc" id="L3884">							return &quot;ListDynamicAction [name=&quot; + dynamicAction.getName() + &quot;, listContext=&quot;</span>
<span class="fc" id="L3885">									+ input.getContext().getIdentifier() + &quot;]&quot;;</span>
						}
					};
				}

				@Override
				public IMethodControlData getControlData() {
<span class="fc" id="L3892">					return new DefaultMethodControlData(swingRenderer.getReflectionUI(), IDynamicListAction.NO_OWNER,</span>
<span class="fc" id="L3893">							dynamicAction) {</span>
						@Override
						public Runnable getLastFormRefreshStateRestorationJob() {
<span class="fc" id="L3896">							return listData.getLastFormRefreshStateRestorationJob();</span>
						}
					};
				}
			});
<span class="fc" id="L3901">			invocationData = action.prepare(ListControl.this);</span>
<span class="pc bpc" id="L3902" title="1 of 2 branches missed.">			return invocationData != null;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="fc" id="L3907">			final Accessor&lt;List&lt;BufferedItemPosition&gt;&gt; defaultPostSelectionGetter = postSelectionGetterHolder[0];</span>
<span class="fc" id="L3908">			action.invokeAndObtainReturnValue(invocationData, ListControl.this);</span>
<span class="fc" id="L3909">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="fc" id="L3912">					List&lt;ItemPosition&gt; result = dynamicAction.getPostSelection();</span>
<span class="pc bpc" id="L3913" title="1 of 2 branches missed.">					if (result == null) {</span>
<span class="fc" id="L3914">						return defaultPostSelectionGetter.get();</span>
					}
<span class="nc" id="L3916">					return MiscUtils.&lt;ItemPosition, BufferedItemPosition&gt;convertCollectionUnsafely(result);</span>
				}
			};
<span class="fc" id="L3919">		}</span>

		@Override
		protected void displayResult() {
<span class="fc bfc" id="L3923" title="All 2 branches covered.">			if (action.shouldDisplayReturnValue()) {</span>
<span class="fc" id="L3924">				action.openMethodReturnValueWindow(ListControl.this);</span>
			}
<span class="fc" id="L3926">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc" id="L3930">			return dynamicAction.getCaption();</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="fc" id="L3935">			return MethodControlDataModification</span>
<span class="fc" id="L3936">					.getTitle(ReflectionUIUtils.composeMessage(getRootListTitle(), dynamicAction.getCaption()));</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc" id="L3941">			return dynamicAction.isEnabled(IDynamicListAction.NO_OWNER);</span>
		}

		@Override
		protected String getActionDescription() {
<span class="fc" id="L3946">			return dynamicAction.getOnlineHelp();</span>
		}
	}

	protected class DynamicPropertyHook extends AbstractStandardListAction {
		protected static final long serialVersionUID = 1L;

		protected IDynamicListProperty dynamicProperty;
		protected AbstractEditorBuilder subDialogBuilder;

<span class="fc" id="L3956">		public DynamicPropertyHook(IDynamicListProperty dynamicProperty) {</span>
<span class="fc" id="L3957">			this.dynamicProperty = dynamicProperty;</span>
<span class="fc" id="L3958">		}</span>

		@Override
		protected boolean prepare() {
<span class="nc" id="L3962">			subDialogBuilder = new AbstractEditorBuilder() {</span>

				@Override
				protected String getCapsuleTypeCaption() {
<span class="nc" id="L3966">					return ReflectionUIUtils.composeMessage(listData.getCaption(), dynamicProperty.getCaption());</span>
				}

				@Override
				protected IContext getContext() {
<span class="nc" id="L3971">					return input.getContext();</span>
				}

				@Override
				protected IContext getSubContext() {
<span class="nc" id="L3976">					return new CustomContext(&quot;ListDynamicProperty [name=&quot; + dynamicProperty.getName() + &quot;]&quot;);</span>
				}

				@Override
				protected boolean isEncapsulatedFormEmbedded() {
<span class="nc" id="L3981">					return dynamicProperty.isFormControlEmbedded();</span>
				}

				@Override
				protected boolean isEncapsulatedisControlValueValiditionEnabled() {
<span class="nc" id="L3986">					return dynamicProperty.isControlValueValiditionEnabled();</span>
				}

				@Override
				protected boolean isNullValueDistinct() {
<span class="nc" id="L3991">					return dynamicProperty.isNullValueDistinct();</span>
				}

				@Override
				public SwingRenderer getSwingRenderer() {
<span class="nc" id="L3996">					return swingRenderer;</span>
				}

				@Override
				protected ValueReturnMode getReturnModeFromParent() {
<span class="nc" id="L4001">					return ValueReturnMode.combine(listData.getValueReturnMode(), dynamicProperty.getValueReturnMode());</span>
				}

				@Override
				protected ITypeInfoSource getEncapsulatedFieldDeclaredTypeSource() {
<span class="nc" id="L4006">					return dynamicProperty.getType().getSource();</span>
				}

				@Override
				protected Object loadValue() {
<span class="nc" id="L4011">					return dynamicProperty.getValue(IDynamicListProperty.NO_OWNER);</span>
				}

				@Override
				protected boolean hasEncapsulatedFieldValueOptions() {
<span class="nc" id="L4016">					return dynamicProperty.hasValueOptions(IDynamicListProperty.NO_OWNER);</span>
				}

				@Override
				protected Object[] getEncapsulatedFieldValueOptions() {
<span class="nc" id="L4021">					return dynamicProperty.getValueOptions(IDynamicListProperty.NO_OWNER);</span>
				}

				@Override
				protected String getParentModificationTitle() {
<span class="nc" id="L4026">					return &quot;Edit &quot;</span>
<span class="nc" id="L4027">							+ ReflectionUIUtils.composeMessage(listData.getCaption(), dynamicProperty.getCaption());</span>
				}

				@Override
				protected boolean isParentModificationVolatile() {
<span class="nc" id="L4032">					return listData.isTransient();</span>
				}

				@Override
				protected ModificationStack getParentModificationStack() {
<span class="nc" id="L4037">					return ListControl.this.getModificationStack();</span>
				}

				@Override
				protected Component getOwnerComponent() {
<span class="nc" id="L4042">					return ListControl.this;</span>
				}

				@Override
				protected boolean canCommitToParent() {
<span class="nc" id="L4047">					BufferedItemPosition anyRootItemPosition = getRootListItemPosition(-1);</span>
<span class="nc" id="L4048">					return anyRootItemPosition.isContainingListEditable();</span>
				}

				@Override
				protected IModification createCommittingModification(Object newObjectValue) {
<span class="nc" id="L4053">					return new FieldControlDataModification(new DefaultFieldControlData(swingRenderer.getReflectionUI(),</span>
<span class="nc" id="L4054">							IDynamicListProperty.NO_OWNER, dynamicProperty) {</span>
						@Override
						public Runnable getLastFormRefreshStateRestorationJob() {
<span class="nc" id="L4057">							return listData.getLastFormRefreshStateRestorationJob();</span>
						}
<span class="nc" id="L4059">					}, newObjectValue);</span>
				}

				@Override
				protected IModification createUndoModificationsReplacement() {
<span class="nc" id="L4064">					return ReflectionUIUtils.createUndoModificationsReplacement(listData);</span>
				}

				@Override
				protected void handleRealtimeLinkCommitException(Throwable t) {
<span class="nc" id="L4069">					swingRenderer.handleException(ListControl.this, t);</span>
<span class="nc" id="L4070">				}</span>

				@Override
				protected IInfoFilter getEncapsulatedFormFilter() {
<span class="nc" id="L4074">					return dynamicProperty.getFormControlFilter();</span>
				}
			};
<span class="nc" id="L4077">			JDialog dialog = subDialogBuilder.createDialog();</span>
<span class="nc" id="L4078">			swingRenderer.showDialog(dialog, true);</span>
<span class="nc" id="L4079">			return true;</span>
		}

		@Override
		protected void perform(Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;[] postSelectionGetterHolder) {
<span class="nc" id="L4084">			final Accessor&lt;List&lt;BufferedItemPosition&gt;&gt; defaultPostSelectionGetter = postSelectionGetterHolder[0];</span>
<span class="nc" id="L4085">			postSelectionGetterHolder[0] = new Accessor&lt;List&lt;BufferedItemPosition&gt;&gt;() {</span>
				@Override
				public List&lt;BufferedItemPosition&gt; get() {
<span class="nc" id="L4088">					List&lt;ItemPosition&gt; result = dynamicProperty.getPostSelection();</span>
<span class="nc bnc" id="L4089" title="All 2 branches missed.">					if (result == null) {</span>
<span class="nc" id="L4090">						return defaultPostSelectionGetter.get();</span>
					}
<span class="nc" id="L4092">					return MiscUtils.&lt;ItemPosition, BufferedItemPosition&gt;convertCollectionUnsafely(result);</span>
				}
			};
<span class="nc" id="L4095">		}</span>

		@Override
		protected String getActionTitle() {
<span class="fc" id="L4099">			return dynamicProperty.getCaption();</span>
		}

		@Override
		protected String getCompositeModificationTitle() {
<span class="nc" id="L4104">			return FieldControlDataModification</span>
<span class="nc" id="L4105">					.getTitle(ReflectionUIUtils.composeMessage(getRootListTitle(), dynamicProperty.getCaption()));</span>
		}

		@Override
		protected boolean isValid() {
<span class="fc" id="L4110">			return dynamicProperty.isEnabled();</span>
		}

		@Override
		protected String getActionDescription() {
<span class="fc" id="L4115">			return dynamicProperty.getOnlineHelp();</span>
		}

	}

	public class ItemValidationError extends Exception {

		private static final long serialVersionUID = 1L;

		protected BufferedItemPosition itemPosition;

		public ItemValidationError(Entry&lt;BufferedItemPosition, Exception&gt; entry) {
<span class="nc" id="L4127">			this(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L4128">		}</span>

<span class="fc" id="L4130">		public ItemValidationError(BufferedItemPosition itemPosition, Exception cause) {</span>
<span class="fc" id="L4131">			super(cause);</span>
<span class="fc" id="L4132">			this.itemPosition = itemPosition;</span>
<span class="fc" id="L4133">		}</span>

		@Override
		public String getMessage() {
<span class="nc" id="L4137">			return &quot;[&quot; + getDisplayPath(itemPosition) + &quot;] &quot; + getCause();</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L4142">			return getMessage();</span>
		}
	}

	public class ListValidationError extends Exception {

		private static final long serialVersionUID = 1L;

		protected Map&lt;BufferedItemPosition, Exception&gt; validitionErrorByItemPosition;

<span class="fc" id="L4152">		public ListValidationError(Map&lt;BufferedItemPosition, Exception&gt; validitionErrorByItemPosition) {</span>
<span class="fc" id="L4153">			super(&quot;Invalid element(s) detected&quot;);</span>
<span class="fc" id="L4154">			this.validitionErrorByItemPosition = validitionErrorByItemPosition;</span>
<span class="fc" id="L4155">			Collection&lt;Exception&gt; validationErros = validitionErrorByItemPosition.values();</span>
<span class="fc" id="L4156">			List&lt;StackTraceElement[]&gt; stackTraceArrays = validationErros.stream().map(e -&gt; e.getStackTrace())</span>
<span class="fc" id="L4157">					.collect(Collectors.toList());</span>
<span class="fc" id="L4158">			StackTraceElement[] allStackTraceElements = new StackTraceElement[stackTraceArrays.stream()</span>
<span class="fc" id="L4159">					.map(st -&gt; st.length).reduce(Integer::sum).get()];</span>
<span class="fc" id="L4160">			int insertionIndex = 0;</span>
<span class="fc bfc" id="L4161" title="All 2 branches covered.">			for (Iterator&lt;StackTraceElement[]&gt; it = stackTraceArrays.iterator(); it.hasNext();) {</span>
<span class="fc" id="L4162">				StackTraceElement[] stackTraceElements = it.next();</span>
<span class="fc" id="L4163">				System.arraycopy(stackTraceElements, 0, allStackTraceElements, insertionIndex,</span>
<span class="fc" id="L4164">						stackTraceElements.length);</span>
<span class="fc" id="L4165">				insertionIndex += stackTraceElements.length;</span>
			}
<span class="fc" id="L4167">			setStackTrace(allStackTraceElements);</span>
<span class="fc" id="L4168">		}</span>

		public List&lt;ItemValidationError&gt; getEntries() {
<span class="fc" id="L4171">			return validitionErrorByItemPosition.entrySet().stream()</span>
<span class="fc" id="L4172">					.map(mapEntry -&gt; new ItemValidationError(</span>
<span class="fc" id="L4173">							((Map.Entry&lt;BufferedItemPosition, Exception&gt;) mapEntry).getKey(),</span>
<span class="fc" id="L4174">							ValidationErrorWrapper.unwrapValidationError(</span>
<span class="fc" id="L4175">									((Map.Entry&lt;BufferedItemPosition, Exception&gt;) mapEntry).getValue())))</span>
<span class="fc" id="L4176">					.collect(Collectors.toList());</span>
		}

		@Override
		public String toString() {
<span class="fc" id="L4181">			return getMessage();</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>j-enterprise-service-bus (java8) (Dec 1, 2025 10:13:41 AM)</div></body></html>